%
%
%

%= Android User Interface =
= Android 用户界面 =[ch6]

% In this chapter, you will learn how to build user interface in Android. You will create your first Activity. You will learn how to create an XML layout for it, and how to connect it to Java. You will learn about Views (a.k.a. widgets) and Layouts. You will learn how to handle events in Java, such as a button click. Additionally, you’ll add the support for twitter-like API into your project as an external jar so your app can make web service calls to the cloud.  

本章介绍Android中用户界面的构建方法。我们将在这里创建第一个Activity作为实例，体验如何使用XML描述界面布局，以及在Java中引用它的方法。随后介绍View(又称Widget，控件)和Layout的概念，以及如何在Java中捕获事件(比如单击按钮)。另外，还需要在这里导入一个三方的jar文件，从而获得访问微博服务的API。

%TALK: Widget能否翻译成“控件”？若与"App Widget"同时保留原文，容易让读者混淆。感觉后者可以翻译成“小部件”。 -fleuria

% By the end of this chapter, you will have written your own Twitter-like Android app. The app will feature a single screen that will prompt user for current status update, and post that update online.

到本章结束，你就有了一个自己编写的微博应用。暂时它只有一个界面，允许用户输入消息并发布到网上。

%== Two Ways to Create User Interface ==
== 创建用户界面的两种方法 ==

% There are two ways to create user interface (UI) in Android. One is declarative and the other one is programmatic. They are quite different but often used together to get the job done.

Android提供了两种风格可供我们创建用户界面(UI)：一种是声明风格，另一种是编程风格。它们之间的差别不小，但是我们想做好界面，往往离不开它们的相互配合。

% === Declarative User Interface ===
=== 声明风格的用户界面===

% Declarative approach involves using XML to declare what the UI will look like. It is similar to creating a web page using HTML. You write tags and specify elements to appear on your screen. If you ever hand-coded an HTML page, you did pretty much the same work as creating an Android screen.

声明风格就是使用XML来声明UI的外观。通过标签表示显示出来的相应元素，这与使用HTML编写网页是很相似的。若是以前写过HTML页面，编写声明式的Android界面也很快就能上手。

% The advantages of declarative user interface are that you can use what-you-see-is-what-you-get (WYSIWYG) tools. Some of these tools ship with Eclipse Android Development Tools (ADT) extension, others come from third parties. Additionally, XML is fairly human readable and event people unfamiliar with the Android platform and framework can readily determine what the intent of the user interface is.

声明风格的好处就是，便于使用所见及所得(WYSIWYG)工具——有些来自Eclipse Android Development Tools(ADT)的扩展，有些来自第三方。另外一个好处是，XML是易于人类阅读的，即使你不熟悉Android的平台与框架，也可以大致看得明白。

% The disadvantages of declarative UI approach are that you can only get so far with XML. XML is great for declaring the look and feel of your user interface, but that doesn’t provide a good way of handling user input. That’s where programmatic approach comes in.

声明风格的缺点是也正在XML本身。描述界面的外观样式，XML自是再合适不过，但是响应外部事件、处理用户交互它就无能为力了。而这就是引入编程风格的理由。

% === Programmatic User Interface ===
=== 编程风格的用户界面 ===

% Programmatic user interface involves writing Java code to develop UI. For anyone who ever did any Java AWT or Java Swing development, Android is pretty much the same in that respect. It is also similar to many other UI toolkits in other languages as well.

编程风格的用户界面就是使用Java代码来编写UI，做过Java AWT或者Java Swing开发的同学对此肯定不会陌生。这跟其它语言中提供的UI库也区别不大。

% Basically, if you want to create a button programmatically, you have to declare the button variable, create an instance of it, add it to a container that is to contain this button, and set any button properties that may make sense, such as color, text, text size, background, and so on. You would probably also want to declare what the button does once the button is clicked, so that’s another piece of code. All in all, you end up writing quite a few lines of Java.

假如你想通过编写代码的方式创建一个按钮，一般就需要声明一个按钮变量、获得按钮的实例、添加到容器里面，然后设置相应的属性——颜色、文本、文本大小、背景颜色等等不一而足。你也希望对按钮的点击事件做些响应，因此还需要添加额外的逻辑。这样一来二去，敲出来的代码是很可观的。

% Everything you can do declaratively, you can also do programmatically. But additionally, Java also allows you to specify what happens when that button is actually clicked. This is the main advantage of programmatic approach to user interface.

理论上讲，声明式风格能做到的，编程风格也都能做到。但是通过Java代码，你能够为按钮的点击事件作出响应——这才是编程风格的主要优点。

% === The Best of Both Worlds ===
=== 各取所长 ===

% So which approach to use? The best practice is to use both. You would use declarative (XML) approach to declare everything about the user interface that is static, such as the layout of the screen, all the widgets, etc. You would then switch to programmatic (Java) approach to define what goes on when user interacts with various widgets of the user interface. In other words, you’d use XML to declare what the "button" looks like, and Java to specify what it does.

好，那我应该选择哪种风格？好的选择是两者皆用：使用声明风格(XML)表示用户界面中的静态元素，比如页面布局、控件摆放等；同时使用编程风格(Java)来定义控件对用户操作的响应。换种说法，就是使用XML描述它的"样子"，而使用Java定义它的"操作"。

{NOTE}
% 	Note that there are two approaches to developing the actual user interface, but at the end of the day, all the XML is actually "inflated" into Java memory space as if you actually wrote Java code. So, it’s only Java code that runs.

虽然两种做法风格迥异，但是到最后XML终究还是要"解析"到Java的运行环境中才可以显示出来。实际运行的只有Java代码。
{/NOTE}


%== Views and Layouts ==
== View与Layout ==

% Android organizes its UI elements into layouts and views. Everything you see, such as a button, label, or text box, is a view. Layouts organize views, such as grouping together a button and label or a group of them.

Android通过Layout与View机制组织UI中元素的显示。View就是屏幕上显示的所有控件——比如按钮、标签、文本框等等。而Layout用来安排View的排列，比如它可以将一组按钮或标签排成一行或者一列。

% [增加 If you have prior experience with Java AWT or Swing, layouts are similar to Java containers and views are similar to Java components. Views in Android are sometimes referred to as widgets.]

如果你有AWT或者Swing的编程经验，那就不难发现Layout对应Java的//容器(Container)//，View对应Java的//组件(Component)//，都是很相似的东西。另外，Android中的View有时也被称作//控件//。

**图 6.1. Layout与View**
	[images/06-LayoutsAndViews.png]

{NOTE}
% 	Don’t confuse widgets in Android UI with App Widgets - miniature application views that can be embedded in other applications (such as the Home screen application). Here, we are referring to widgets as views in our activities.

不要将Android UI中的控件(Widget)与应用程序小部件(App Widget)相混淆，后者是指可以嵌入到其它应用程序(如主屏幕程序)里面显示的小程序。而这里我们谈到的控件(Widget)，是指Acitivity中的View。
{/NOTE}

% So, a layout can contain other children. Those children can furthermore be layouts themselves allowing for complex user interface structure.

可以把Layout看作是容纳一些子元素的容器。这些子元素可以是View，也可以是Layout本身，这样可以方便组合出复杂的用户界面。

% A layout is responsible for allocating space for each child. Different layouts use different approach to laying out their child widgets. [增加 as shown in Figure 6.1, “Layouts and Views relationship”.]

Layout为每个子元素安排位置，不同的Layout提供不同的安置方法。

%NOTE: 当心，这个allocating space不是“申请内存”，而是老老实实的“申请(放置的)空间”。 -fleuria

% There are couple of main layouts that we use more frequently than others, such as Linear Layout, Table Layout, Frame Layout, Relative Layout, and Absolute Layout.

Android框架中内置的Layout各种各样，不过常用的大约也就这几个：LinearLayout, TableLayout, FrameLayout, RelativeLayout和AbsoluteLayout。

=== LinearLayout ===

% LinearLayout is one of the simplest and most common layouts. It simply lays out its children next to each other, either horizontally or vertically. The order of children matters. As LinearLayout asks its children for how much space they need, it allocates desired space to each child in the order they are added. So, if an "older" child comes along and asks for all the space on the screen, there won’t be much left for the subsequent widgets in this layout.

LinearLayout是最简单的Layout之一，只是简单地纵向或者横向排列它的子元素。它会按顺序计算每个子元素需要的空间，如果一个“较早加入的”元素占据了整个屏幕大小，后面的元素就显示不出来了。因此子元素的顺序很重要。

% An important property for LinearLayout are layout_orientation and valid options are vertical or horizontal.

LinearLayout的一个重要属性是layout_orientation。可用的选项有Vertical和Horizontal，用以指示它是水平排列还是垂直排列。

{TIP}
% 	While Linear Layout is probably the simplest and most commonly used layout, it is not always the best choice. A good rule of thumb is that if you start to nest multiple Linear Layouts, you should probably be using another layout, such as Relative Layout. Too many nested layouts can have big consequences on the time to inflate the UI and overall CPU and battery consumption.

LinearLayout可能是最简单也最常用的Layout，但它并不总是最好的选择。一条经验是，一旦你想嵌套多个LinearLayout，那就换用别的Layout吧，比如RelativeLayout之类。Layout如果嵌套的太深，会浪费较多的CPU时间，电池的续航也会因此而受到影响。

%NOTE: “a good rule of thumb”是个俚语， "经验之谈."的意思

{/TIP}

=== TableLayout===

% TableLayout lays out its children in a table. TableLayout consists of only other TableRow widgets. TableRow represents a row in a table and can contain other UI widgets. TableRow widgets are laid out next to each other horizontally, sort of like LinearLayout with horizontal orientation.

TableLayout将其子元素布局在一个表格之中。TableLayout只接纳TableRow作为自己的子元素，表示表格中的一行，下面可以容纳其它子元素。TableRow水平地排列它的子元素，这同水平排列的LinearLayout很像。

% For those familiar with HTML, Table Layout is similar to <table> element, while Table Row is similar to the <tr> element. Where as in HTML we also have <td> to represent each cell in the table, in Android the columns are determined dynamically based on the number of views we add to a table row.

熟悉HTML的同学可能会有同感，TableLayout接近于<table>标签，而TableRow接近于<tr>标签。不过Android中并没有<td>的对应物，每一行的列数由TableRow的子元素的个数动态决定。

% An important property for TableLayout is stretch_columns indicating index of column to stretch to fill out available space. You can also use * to stretch all columns.

TableLayout的一个重要属性是stretch_columns，可以用它来展开列号对应的列来占据可用的空间。也可以通过*来展开所有的列。

=== FrameLayout ===

% FrameLayout places its children on top of each other so that latest child is covering the previous, like a deck of cards. This layout policy is useful for tabs, for example. FrameLayout is also used as placeholder for other widgets to be added to it programmatically at some later point in time.

FrameLayout将其下的子元素相互覆盖起来，就像一副扑克牌，只留一个显示在外面。它可以用于标签的实现，也可以作为以后要用的控件的临时存放地。

=== RelativeLayout ===

% RelativeLayout lays out its children relative to each other. As such, it is very powerful as it doesn’t require you to nest unnecessary layouts in order to achieve certain look. At the same time, using RelativeLayout can minimize total number of widgets that need to be drawn thus improving the overall performance of you application. Having said that, RelativeLayout requires each of its child views to have an ID set so that we can position it relatively to other children.

RelativeLayout实现子元素的相对布局。它十分强大，不需要嵌套就可以实现复杂的布局，同时还可以减少使用的控件的数量，从而提高程序的整体性能。RelativeLayout需要我们为它的每个子元素提供一个ID，你可以单独设置它们的相对位置。

=== AbsoluteLayout ===

% AbsoluteLayout positions its children at absolute coordinates on the screen. It is the favorite layout for WYSIWYG tools that automatically generate your UI. While very simple, it is not very flexible. Your user interface would look good on one particular screen but as soon as the screen size, orientation, or density changes, AbsoluteLayout would not be able to adjust.

AbsoluteLayout可以为它的子元素设置一个屏幕上的绝对位置。这个Layout简单易懂，对所见及所得工具来说是再好用不过。缺点就是不那么灵活，在某个屏幕上显示很好的界面，换个不同大小、宽高、分辨率的屏幕可能就不能正常显示了。

%== Starting Yamba Project ==
== 启动Yamba项目 ==

% We are about to start our Yamba project. So, fire up your Eclipse and click on File→New→Android Project.

接下来开始编写Yamba。打开你的Eclipse，选择File→New→Android Project。

% You will get a dialog window asking you about your new Android project [增加 (see Figure 6.2, “New project dialog”)]. Let’s explain again all the different fields that are significant.

然后出现一个对话框，要求你输入有关新项目的各种信息。其中重要的条目如下：

//Project Name//
% The name under which Eclipse organizes our project. Is is a good idea if the project name doesn’t have any spaces in it - makes it easier to access from the command line later. Enter Yamba here.

这是Eclipse项目的名字。出于方便以后使用命令行的考虑，最好不要在项目名里夹带空格。输入``Yamba``。

//Contents//
% Leave this as is, set to creating a new project since that’s what we’re intending to do.

保留默认选项也就是``creating a new project``，不需要修改。

//Build Target//
% The type of Android system we are intending to run this application on. This could be any Android platform, either standard or proprietary. I’m assuming we’re working with Android 2.3 (API level 9) and thus will choose Android 2.3.

目标平台的版本。不分标准版还是定制版，只要是Android平台即可。前面我们既已定下将Android 2.3 (API level 9)作为目标平台，在这里就选择``Android 2.3``。

%NOTE：最新2.3.1（API Level 9）已过时，2.3的最新版本是2.3.3（API Level 10）。 -elephas

//Application name//
% Simply a plain text name of your application. It can be any text. For our app, feel free to enter Yamba.

应用程序的名字。要求是纯文本，内容可以是任何有效字符。在这里输入``Yamba``即可。

//Package name//
% A Java package, and as such it needs to adhere to Java package naming convention. In a nutshell, you want to use the reverse of your domain name for your package. I’m going to use com.marakana.yamba here.

按照Java package的命名规范为项目的package命名，也就是逆序的域名形式。在这里使用``com.marakana.yamba``。

//Create Activity//
% An option to create an activity as part of this project. You can leave it checked. For the activity name, we must adhere to Java class naming convention. That simply means use upper CamelCase convention. I’m going to enter StatusActivity here

是否为项目默认创建一个Activity。保留默认的选中即可。Activity的名字必须遵循Java类的命名规范，也就是CamelCase命名法。在此输入``StatusActivity``。

//Min SDK Version//
% Represents the minimum version of Android SDK that is installed on the device in order to be able to run this particular application. Typically, this number will correspond to the API level that you picked for your target, in our case Android 9. However, if the app doesn’t depend on latest-greatest API or is capable of scaling gracefully to lower API, you should rethink this number. In our case, the app will be able to work on API level 4 (Android 1.6). So, enter 4 here. This is good because we can distribute our app to way more people than if minimum was Android 2.3.

表示支持平台的最低版本。一般这个数字与前面的API Level是相互对应的，不过你的应用若并没有高版本API的依赖，那就可以降低这个数字。我们的应用最低可以在API Level 4(Android 1.6)上运行，因此输入``4``。一个较低的API Level有助于提高兼容性，从而允许更多的用户使用它。

% Click on Finish. You should have Yamba project now appear in your Package Explorer in Eclipse.

单击Finish。即可在Eclipse的Package Explorer里面见到一个新的项目，也就是Yamba。

**图 6.2. New Project对话框**
	[images/06-NewProjectDialog.png]



%== StatusActivity Layout ==
== StatusActivity Layout ==

% Let’s start by designing the user interface for our screen where we’ll enter the new status and click a button to update it.
接下来开始设计一个用户界面，用户可以在里面输入新消息并发布。

% By default, Eclipse created a file called main.xml under res/layout folder. For consistency purposes, we should rename this file to status.xml to match our StatusActivity. To rename a file in Eclipse, right-click on it, choose Refactor→Rename… and enter new name. Eclipse is somewhat smart about renaming files and does more than just change the name. It also offers to lookup all the places where this file is referred from and update those references as well. While this feature works well when renaming a Java file, it is not fully automatic with XML files. So, renaming this file requires us to change the line in Java where we refer to it via the R class. To do that, in your StatusActivity’s onCreate(), change setContentView(R.layout.main); to setContentView(R.layout.status);.


Eclipse默认会在``res/layout``下创建一个``main.xml``文件。出于一致性的考虑，我们将把它的名字改为``status.xml``以对应StatusActivity。在Eclipse中重命名一个文件，就右键点击它，选择//Refactor→Rename…//，输入新名字即可。Eclipse在重命名时会智能地做些同步工作，使所有引用到这个文件的地方保持一致。这在更新Java文件时可以做到完全自动，但对XML文件就不那么尽善尽美了。修改一个XML文件名，我们还需要手工修改Java代码中引用R class的相关部分。比如在这里，就需要将``onCreate()``里的``setContentView(R.layout.main)``修改为``setContentView(R.layout.status)``。

%TALK: "So, renaming this file requires us to change the line in Java where we refer to it via the R class." 很绕的一句。

% This screen will have four components:
这个界面分为四部分：

% - Title at the top of the screen. This will be a TextView widget.
% - Big text area to type our 140-character status update. We’ll use EditText widget for this purpose.
% - Button to click to update the status. This will be a Button widget.
% - A layout to contain all these widgets and lay them out one after another in vertical fashion. For this screen, we’ll use LinearLayout, one of the more common ones.

- 屏幕上方显示的标题，TextView控件。
- 微博消息的输入框，在此使用EditText控件。
- 更新状态的按钮，Button控件。
- 一个容纳以上所有控件的Layout，它负责将这些控件垂直排开。在此选用前面提到的常用Layout之一——LinearLayout。

% The source code for our StatusActivity layout looks like this:

StatusActivity的源码大致如下：

**Example 6.1. res/layout/status.xml**
{CODE}
<?xml version="1.0" encoding="utf-8"?>

<!-- Main Layout of Status Activity -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:orientation="vertical" android:layout_width="fill_parent"
  android:layout_height="fill_parent">

  <!-- Title TextView-->
  <TextView android:layout_width="fill_parent"
    android:layout_height="wrap_content" android:gravity="center"
    android:textSize="30sp"
    android:layout_margin="10dp" android:text="@string/titleStatus"/>

  <!-- Status EditText  -->
  <EditText android:layout_width="fill_parent"
    android:layout_height="fill_parent" android:layout_weight="1"
    android:hint="@string/hintText" android:id="@+id/editText"
    android:gravity="top|center_horizontal"></EditText>

  <!-- Update Button -->
  <Button android:layout_width="fill_parent"
    android:layout_height="wrap_content" android:text="@string/buttonUpdate"
    android:textSize="20sp" android:id="@+id/buttonUpdate"></Button>

</LinearLayout>
{/CODE}

% This code was generated by Eclipse Graphical Layout [增加 , shown in Figure 6.3, “Graphical Layout mode for status.xml”.]. This is the part of Android Development Tools (ADT) for Eclipse plugin that helps you work with Android-specific XML files. Since ADT knows that you are working on a UI layout, it opens status.xml in Graphical Layout mode. You can also view the raw XML by choosing status.xml tab at the bottom of this window. That will give you the XML source code for this screen, as displayed above.

以上代码由Eclipse Graphical Layout自动生成，它是作为Eclipse插件的Android Development Tools(ADT)的一部分，即编辑Android中XML文件的辅助工具。ADT可以辨认出这是在编辑用户界面的Layout，因此按照Graphical Layout模式打开status.xml，很方便就可以生成上述的代码。

**图 6.3. status.xml的Graphical Layout**
	[images/06-GraphicalLayout.png]

% Although we discussed the basic meaning of these XML resources in a previous chapter, there are some details in the code that you should know more about, which we’ll examine in the following section.

在前面的章节里，我们已对这些XML资源的概念略有提及，但是代码中存在的细节仍是需要在后面慢慢体会的。

% === Important Widget Properties ===
===控件的常用属性===

% The properties you are most likely to use regularly are:

一般来讲，这就是最常用的几个属性：

**layout_height and layout_width**

% Defines how much space this widget is asking from its parent layout to display itself. While you could enter a value in pixels, inches, or similar, that is not a good practice. Since your application could run on many different devices with various screen sizes, you want to use relative size for your components, not absolute. So, best practice would be to use either fill_parent or wrap_content for the value. fill_parent means that your widget wants all the available space from its parent. wrap_content means that it only requires as much space as it needs to display its own content. Note that in API Level 8 and higher, fill_parent has been renamed to match_parent.

表示控件在父元素中占据的空间。在这里可以明确给出像素、英寸等单位的值，但这样是不提倡的。你的程序需要运行在不同的设备上，它们屏幕的尺寸会有不同，因此绝对大小不如相对大小。提倡的是，在这里给出fill_parent或者wrap_content，分别表示占据父元素的所有可用空间，或者仅占据自己全部显示所需要的最小空间。留意，自API level 8开始，fill_parent改为match_parent。

**layout_weight**

% Layout weight is a number between 0 and 1. It implies the weight of our layout requirements. For example, if our Status EditText had default layout weight of 0, and required layout height of fill_parent, then the Update button would have been pushed out of the screen since Status, and its request for space came before the button. However, when we set Status widget’s layout weight to 1, we are saying we want all available space height-wise, but are yielding to any other widget that also may need space, such as the Update button.

表示布局的权重，0或者1。比如消息框对应的EditText控件的默认布局权重是0，设定的布局高度(layout height)是fill_parent，而且它在发送按钮之前先一步申请空间，这样发送按钮就被挤出屏幕之外而无法显示了。为了让发送按钮显示出来，我们可以把消息框的布局权重设为1，这样它依然会在高度上占据尽可能多的空间，不过如果还有其它控件，就会为它们让出合适的空间，使之可以显示。

**layout_gravity**
% Specifies how this particular widget is positioned within its layout, both horizontally and vertically. Values could be top, center, left, and so on. Notice the difference between this property and gravity below. For example, if you have a widget that has width set to fill_parent, trying to center it wouldn’t do much since it’s already taking all available space. However, if our title TextView had width set to wrap_content, centering it with layout_gravity would generate desired results.

指明这一控件在布局中所在的水平位置或垂直位置，可选的值为top、center、left等。若把某控件的宽度设为fill_parent，再给它一个center的水平位置显然是没有意义的。不过把控件的宽度设为wrap_content，再给它一个center的layout_gravity就令它居中。需要注意的是这个属性与下面``gravity``的区别。

**gravity**
% Specifies how the content of this widget is positioned within the widget itself. It is commonly confused with layout_gravity. Which one to use will depend on size of your widget and desired look. For example, if our title TextView had width fill_parent, then centering it with gravity would work but centering it with layout_gravity wouldn’t do anything.

指定控件的内容在这个控件中的位置。人们很容易将它与layout_gravity相混淆，实际上它们的应用场景不同。比如，我们作为标题的TextView的宽度设为fill_parent，那么设置它的``layout_gravity``就没有用处，不过将其gravity设为center可以让它的文字居中。

**text**
% Not all widgets have this property, but many do, such as Button, EditText, and TextView. It simply specifies the text for the widget. Now, it is not a good practice to just enter the text because than your layout will only work in one locale/language. Best practice is to define all text in strings.xml resource and refer to particular string via this notation: @string/titleStatusUpdate.

不是所有控件都有这个属性，但它十分常见，比如Button、EditText和TextView。它指定控件显示的文本。但是在这里直接输入文本是不被提倡的，因为这样就限制了程序的语言环境。好的做法是将所有的文本放到string.xml资源文件里，按照``@string/titleStatusUpdate``这样的形式引用它。

**id**
% id is simply the unique identifier for this particular widget in particular layout resource file. Not every widget needs an id and I recommend removing id’s if not needed to minimize clutter. But widgets that we’ll later need to manipulate from Java do need id’s. Id has the following format: @+id/someName where someName is whatever you want to call your widget. My naming convention is to use type followed by name, so @+id/buttonUpdateStatus for example.

id是控件在layout资源文件中的唯一标识符。id对控件而言不是强制的，我也建议尽量少用id以减少重名的机会。但是在Java中需要引用控件的话，id是必须的。Id的格式为: @+id/someName，其中someName就是对应widget的名称。我个人的命名习惯是在名字前面加上类型，比如@+id/buttonUpdateStatus这样。

=== Strings Resource ===

% Android tries hard to keep data in separate files. So, layouts are defined in their own resources, and all text values (such as button text, title text, etc.) should be defined in their own file called strings.xml. This later allows you to provide multiple versions of strings resources to be used for various languages, such as English, Japanese, or Russian.

Android精细地划分了文件的职责：布局在资源文件中给出了定义，文本值（按钮的文本、标题等）也都独立到string.xml文件之中。这一来为程序提供多语言版本(英语、日语、俄语等)也就容易了许多，只需要提供另一个string资源文件即可。

% Here’s what our strings.xml file looks like at this point: [修改为 Example 6.2, “res/values/strings.xml” shows what our strings.xml file looks like at this point.]
现在string.xml的内容大致如下：

**Example 6.2. res/values/strings.xml**

{CODE}
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <string name="app_name">Yamba 1</string>

  <string name="titleYamba">Yamba</string>
  <string name="titleStatus">Status Update</string>

  <string name="hintText">Please enter your 140-character status</string>
  <string name="buttonUpdate">Update</string>
</resources>
{/CODE}

% That this is simply a set of name/value pairs.
就是一组键值对。

{TIP}
% 	I use a certain naming convention for my resource names. Let’s look at titleYamba, for example. First, I prefix the resource with the name of what it is, in this case a title of the activity. Secondly, I give it a name, Yamba. This naming convention helps later on keep many different resources sorted in a easy to find way. Finally, I use CamelCase for my names while some may prefer to use underscores to separate words.

对资源的命名，建议使用统一的的命名规范。比如titleYamba这个名字，就是以资源的用途——标题(title)——作为前缀。后跟一个名字(Yamba)。多个单词之间使用CamelCase命名法表示分隔。这样使得不同的资源容易区分，也容易查找。
{/TIP}


==StatusActivity类==

% Now that we have our UI designed in XML, we are ready to switch over to Java. Remember from earlier in this chapter that Android provides two ways to building user interface. One is by declaring it in XML, which is what we just did. And we got as far as we could (for now). The other one is to programmatically build it in Java. We also said earlier that the best practice is to get as far as possible in XML, and then switch over to Java.

现在已经有了设计好的XML界面，接下来转到Java这边。本章的开头曾提到构建用户界面有两种方式：一种使用XML的声明风格界面，也正是我们前面所做的；另一种是使用Java的编程风格。而最佳实践是尽可能多地使用XML来描述界面，到最后使用Java专门处理外部交互。

% Our Java class for this is StatusActivity.java and the Eclipse New Project Dialog has already created the stub for this class for us. The class is part of com.marakana.yamba1 Java package, and as such is part of that directory.

Java部分对应的文件是``StatusActivity.java``，Eclipse New Project对话框已在里面生成了类的大体框架。这个类是``com.marakana.yamba1`` package的一部分，因而肯定是在它的目录之下。


% === Creating your application-specific object and initialization code ===
===编写自己的对象，以及初始化的相关代码===

% As with all Main Building Blocks in Android, such as Activities, Services, BroadcastReceivers and ContentProviders, you usually start by subclassing a base class provided by the Android framework, and overriding certain inherited methods. In this case, we subclass Android’s Activity class and override its onCreate() method. As you recall, activities have a certain lifecycle the section called “Activity Lifecycle” [增加 Example 6.2, “res/values/strings.xml” shows what our strings.xml file looks like at this point.], or state machine through which they go. We as developers do not control what state the activity is in, but we do get to say what happens at a transition to a particular state. In this case, the transition we want to override is onCreate() method that is invoked by the system’s ActivityManager when the activity is first created (i.e. it goes from Starting the section called “Starting State” to Running the section called “Running State” state). This sort of programming when we subclass a system class and fill out the blanks is also known as Template pattern.

Android程序中所有的构件(如Activity、Service、BroadcastReceiver、ContentProvider)都是继承一个Android框架中提供的基类，然后覆盖特定的方法。在这里，我们继承Activity类，覆盖了``onCreate()``方法。前面曾提到，Activity有个精心设计的生命周期，作为指导Activity行为的一台状态机。身为开发者，我们通常不会主动地干涉Activity的状态，而是跟踪Activity状态的变更，被动地对事件做处理。在这里，我们的``onCreate()``会在Activity第一次创建时由系统的ActivityManager负责调用。像这样继承一个基类然后覆盖特定的方法的编程范式，被称作Template模式。

%TALK:  (i.e. it goes from Starting the section called “Starting State” to Running the section called “Running State” state). 很诡异的一句。

% Our onCreate(), in addition to doing some standard housekeeping, will carry out two major tasks that the application needs done just once, and done at the beginning. We’ll set up our button so it responds to clicks, and connect to the cloud.

``onCreate()``方法在基本工作之余，还会做些杂事，处理些一次性的初始化工作。比如为按钮绑定点击事件、将程序连接到服务端等。

% Notice that onCreate() take a Bundle as a parameter. This is a small amount of data that can be passed into the activity via the Intent that started it. The data provided in a Bundle is typically limited to basic data types and more complex ones need to be specially encoded. For the most part, we’re not going to be using Bundle in Yamba example as there’s no real need for us.

留意``onCreate()``有个Bundle类型的参数。它表示启动这一Activity的Intent所附带的少量数据。Bundle只能存储基本类型，复杂的数据需要自己编码。不过话说回来，在Yamba中我们并无使用Bundle的特殊需求，也就没有使用它。

% Keep in mind that whenever you override a method, you first want to make a call to the original method provided by the parent. That’s why we have super.onCreate() call here.

永远记住：不论何时，只要覆盖了一个方法，就首先调用父类中原先的方法。而这里的做法就是``super.onCreate()``。

% So, once you subclass the framework’s class, override the appropriate method, and call super’s method in it, you are still back at status quo - your code does the same thing the original class did. But now we have a placeholder where we can add our own code.

这样就保留了父类的逻辑。我们可以将自己的逻辑跟在后面，但并不希望从零做起。

% The very first thing we typically do in activity’s onCreate() is to load the UI from the XML file and inflate it into the Java memory space. In other words, we write some Java code that opens up our XML layout file, parses it, and for each element in XML it creates a corresponding Java object in our memory space. For each attribute of a particular XML element, this code will set that attribute on our Java object. This process is called inflating from XML and the line of code that does all this is setContentView(R.layout.status);.  

% Remember that R class is the automatically generated set of pointers that helps connect the world of Java to our world of XML and other resources in /res folder. Similarly, R.layout.status points to our /res/layout/status.xml file.

``onCreate()``所做最基本的工作之一就是，读取XML文件并将UI投射到Java中。也就是编写Java代码读取并解析XML文件，为XML中表示的每个元素创建一个对应的Java对象，这被称作UI的“投射”(inflating)。而这一步的所有代码，全在``setContentView(R.layout.status);`` 这一句。

R文件是Eclipse自动生成的资源文件，作为Java与其它资源文件之间的牵线人，储存着一些辅助性质的指针。比如，R.layout.status就是指向``/res/layout/status.xml``文件的指针。

% This method setContentView() does a lot of work, in other words. It reads the XML file, parses it, creates all the appropriate Java objects to correspond to XML elements, sets object properties to correspond to XML attributes, sets up parent/child relationships between objects and overall inflates the entire view. At the end of this one line, our screen is ready for drawing.

显而易见，``setContentView()``做了很多工作。读取文件、解析XML、创建XML元素对应的Java对象、设置对象的属性、处理对象的从属关系、投射整个View。待一切就绪，随后就是重绘界面了。

% Your objects are not the only ones that define methods and respond to external stimuli. Android’s user interface objects do that too. Thus, you can tell your Button to execute certain code when its clicked. To do that, you need to define a method named onClick() and put the code there that you want executed. You also have to run the setOnClickListener method on the Button. You pass this as an argument to setOnClickListener because your object is where you define onClick(). [增加 Example 6.3, “StatusActivity.java, version 1” shows our first version of StatusActivity.java, with some additional explanation following the code.]

添加处理外部事件的响应函数，不一定需要额外派生一个类。Android的UI对象对此已做考虑。比如，想让某按钮处理点击事件，你可以定义一个方法``onClick()``，然后调用setOnClickListener，将this传给它，因为``onClick()``的定义正在这个对象里面。

**Example 6.3. StatusActivity.java, version 1**

{CODE}
package com.marakana.yamba1;

import winterwell.jtwitter.Twitter;
import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;

public class StatusActivity1 extends Activity implements OnClickListener { // #{1}
  private static final String TAG = "StatusActivity";
  EditText editText;
  Button updateButton;
  Twitter twitter;

  /** Called when the activity is first created. */
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.status);

    // Find views
    editText = (EditText) findViewById(R.id.editText); // #{2}
    updateButton = (Button) findViewById(R.id.buttonUpdate);

    updateButton.setOnClickListener(this); // #{3}

    twitter = new Twitter("student", "password"); // #{4}
    twitter.setAPIRootUrl("http://yamba.marakana.com/api");
  }

  // Called when button is clicked // #{5}
  public void onClick(View v) {
    twitter.setStatus(editText.getText().toString()); // #{6}
    Log.d(TAG, "onClicked");
  }
}
{/CODE}

% + To make StatusActivity capable of being a button listener, it needs to implement OnClickListener interface.
% + Find views inflated from the XML layout and assign them to Java variables.
% + Register the button to notify this i.e. StatusActivity when it gets clicked on.
% + Connect to the online service that supports Twitter API. At this point, we hard code the username and password.
% + The method that is called when button is clicked, as part of OnClickListener interface.
% + Make the web service API call to the cloud to update our status.

+ 要让StatusActivity捕获按钮的事件，因此为它实现一个OnClickListener接口。
+ 找到对应的View。
+ 将这个按钮注册，使它按下时能够通知到StatusActivity。
+ 连接到Twitter API的服务端。在这里，我们硬编码了用户名与密码。
+ OnClickListener接口的实现部分，表示按钮按下时调用的方法。
+ 调用Twitter的API，将消息更新到服务端。


% === Compiling Code and Building Your Projects: Saving Files ===
===保存文件：同时构建项目===

% Once you make changes to your files, Java or XML, make sure you save them before moving on. Eclipse builds your project automagically every time you choose File→Save or press Ctrl-S. So, it is important to save files and make sure you do not move to another file until the current file is fine. You will know your file is fine if there are no little red x symbols in your code and the project builds successfully. Since Java depends on XML and vice versa, moving to another file while the current one is broken just makes it even more difficult to find errors.

对文件做过更改，不管是Java文件还是XML文件，都得记着保存它们。在点击File->Save或按下Ctrl-S时，Eclipse都会自动重新构建项目。因此在保存一个文件并确保无误之前，最好不要修改其它文件，以免引入别的错误。若项目构建失败，代码中会出现红色的x标志，可以凭此判断这个文件中是否有错误存在。Java与XML相互依赖，修改起来若不顾顺序，同时修改又同时保存，一次正确还好，出现错误的话只会让错误更加难以寻找。

%TALK: "move to another file"意思很含糊。在这里不是指“移动文件到另个地方”，而是“转移注意力，编辑另个文件”。

% Java errors are typically easy to find since the little red x in the code navigates you straight down to the line number where the error occurred [增加 (see Figure 6.4, “Tracing Java errors”)]. By putting your mouse right on that error, Eclipse will tell you what the error is and it will also offer you some possible fixes. This feature of Eclipse is very useful and is analogous to spell checker in a word processor.

有代码中红色的x标志在，Java中的错误一般还比较容找到。只要将鼠标移向那个错误标志，Eclipse即可告诉你错误的类型、位置，以及可能的修复方法。Eclipse的这一功能堪比文字处理工具中的拼写检查，十分有用。

	**图 6.4. 跟踪Java的错误**
		[images/06-TracingJavaErrors.png]

% === Adding jtwitter.jar Library ===
===添加库jtwitter.jar===

% We are connecting to the the online service that implements Twitter-compatible API in our application. This connection is done via a series of web service calls. Since Android uses standard Java networking capabilities, there’s not much new in Android with respect to web services than we already have in Java. So, as such, there’s little value in reinventing the wheel.

我们的程序需要连接到服务端访问Twitter的API服务，免不了一系列的网络操作。Android拥有Java标准的网络编程接口，因此Java中的许多网络服务可以直接拿来，而没有重复发明轮子的必要。

% To make our life with web services and Twitter API easier, we’re going to use a third-party library, jtwitter.jar, provided by Winterwell Associates. This library provides a simple Java class to interact with the online service and abstracts all the intricacies of making network calls and passing the data back and forth. If no one has been kind enough to provide a high-level library like jtwitter for what we want to do, we could always use standard Java networking libraries to get the job done. It would just have been more work.

为更方便地使用网络服务和Twitter API，我们选用了Winterwell Associaties的三方库jtwitter.jar。它提供了一个简单的类，使得与Twitter服务端之间的交互变得十分方便。不过，如果没有jtwitter这样的三方库怎么办？我们大可使用Java内置的网络库来封装一个自己的实现，只是稍麻烦些罢了。

{NOTE}
% 	The jtwitter.jar library provided with this code has been slightly modified from the official Winterwell version to make it work in Yamba project.

便于应用到Yamba，这里的jtwitter.jar已略作改动。

{/NOTE}

% Once you download this library, you can put it inside your project in Eclipse. You can simply drag the jtwitter.jar file and drop it in the root of your Eclipse project in Package Manager window. This makes the file part of the project, but our Java code is still unable to locate it.

下载完毕，即可将它加入你的Eclipse项目。需要做的就是打开这个Eclipse项目，把这个文件拖放到Package Manager窗口的根目录之下。这样它就成为了项目的一部分，但我们的Java代码依然不可以访问它。

% Java searches for all the classes in its classpath. To add it to the classpath, right-click on your project, select Properties and you will get a Properties for Yamba dialog window [增加 (see Figure 6.5, “Properties for Yamba dialog window in Eclipse, where we add the jtwitter.jar file”). ]. Select Java Build Path and choose Libraries tab. In there, click on Add JARs… and locate your jtwitter.jar file. This will add this JAR file to your projects classpath.

Java在classpath中搜索它所有的类。要让我们的代码可以访问这个三方库，就需要将他的地址添加到classpath。右击你的项目，选择Properties打开Yamba的属性对话框。找到Java Build Path，选择Libraries页面。在这里单击Add JARs…，找到jtwitter.jar文件，加入即可。

**图 6.5. Yamba的属性**
	[images/06-PropertiesForYamba.png]


% === Updating Manifest File for Internet Permission ===
===更新Manifest文件，获取Internet权限===

% Before this application can work, we must ask user to grant us right to use the internet. The way Android manages security is by specifying permissions needed for certain dangerous operations. User then must explicitly grant those permissions to each application when he/she installs the application first time around. User must grant all or no permissions that the application asks for - there’s no middle ground. Also, user is not prompted about permissions upon upgrading an existing app.

这个程序要正常工作，不能没有Internet的访问权限。Android的安全机制要求为可能的危险操作指明所需的权限。在用户安装应用程序时，必须明确地授予它一定的权限。对应用程序所要求的权限，用户只能全部授予，抑或全部拒绝——没有折中的余地。随后在升级已有应用时，就不再需要用户授权了。

{NOTE}
% 	Since we are running this application in debug mode and installing it via USB cable, Android doesn’t prompt us for permissions like it would the end user. However, we still must specify that the application requires certain permissions.

对通过USB安装、以debug模式运行的程序而言，Android不会询问权限的问题。但是应用要发布，我们就必须为应用程序指明它所需的权限。
{/NOTE}

% In this case, we want to ask user to grant this application the use of INTERNET permission. We need internet in order to connect to the online service. So, open up AndroidManifest.xml file by double-clicking on it. Note that Eclipse typically opens this file in a WYSIWYG editor with many tabs on the bottom. As always, you can make most of the changes to this file via this interface, but since Eclipse tools are limited and sometimes buggy, we prefer to go straight into the XML view of this file. So, choose the right-most tab in the bottom that says AnddroidManifest.xml and add <uses-permission android:name="android.permission.INTERNET" /> element within the <manifest> block. [增加  (see Example 6.4, “AndroidManifest.xml”).]

在这里，我们要求访问网络服务，因此需要用户为它授予INTERNET的访问权限。双击打开AndroidManifest.xml文件，Eclipse通常会按照WYSIWYG的形式打开它。同前面一样，在这个界面中即可完成绝大部分的工作，但是Eclipse的这一功能并不完整，灵活性也差强人意，我们不如直接修改源文件。因此，选择最右边显示"AndroidManifest.xml"的标签，将``<uses-permission android:name="android.permission.INTERNET" />``加入``<manifest>``元素之下。

**Example 6.4. AndroidManifest.xml**
{CODE}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  android:versionCode="1" android:versionName="1.0" package="com.marakana.yamba1">
  <application android:icon="@drawable/icon" android:label="@string/app_name">

    <activity android:name=".StatusActivity" android:label="@string/titleStatus">
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
    </activity>

  </application>
  <uses-sdk android:minSdkVersion="4" />

  <uses-permission android:name="android.permission.INTERNET" /><!-- #{1} -->
</manifest>
{/CODE}

% + Defines the <uses-permission> element for INTERNET permission.
+ 定义<uses-permission>元素，申请INTERNET权限。


==Android的日志机制 ==

% Android offers a system-wide logging capability. You can log from anywhere in your code by calling Log.d(TAG, message), where TAG and message are some strings. TAG should be a tag that is meaningful to you given your code. Typically, tag would be the name of your app, your class or some module. Good practice is to define TAG as a Java constant for your entire class, such as:

Android拥有一套系统级的日志机制。在代码的任何位置，都可以调用``Log.d(TAG, message)``来记录日志。其中的TAG与message都是字符串。TAG是一个标志，通常按照应用的名称、类名、模块名取名字。好习惯是，在类中专门为它定义一个常量，比如：

{CODE}
private static final String TAG = "StatusActivity";
{/CODE}

{TIP}
% 	Before your code will compile, you need to import Log class. Eclipse has a useful feature under Source→Organize Imports, or Ctrl+O for short. Usually, this feature will automatically organize your import statements. However, in case of Log, there is usually a conflict because there are multiple classes with name Log. This is where you have to use your common sense and figure it out. In this case, the ambiguity is between Android Log and Apache Log classes, so choice should be easy.

在编译之前需要确保已经import了Log类。有关import，Eclipse有个快捷功能可用，那就是选择Source→Organize Imports或按下Ctrl+O，Eclipse即可自动组织代码中的import语句。但是对Log类来说有一点需要注意，那就是它的名字比较常见，也就比较容易产生冲突。这时就需要靠自己的直觉做选择，辨认出正确的import语句。比如在这里，选择Android Log类还是Apache Log类，是很明显的事情。
{/TIP}

% Note that Log takes different severity levels. .d() is for debug level. You can also specify .e() for Error, .w() for warning, .i() for info. There’s also .wtf() severity level for errors that should never happen. It stands for What a Terrible Failure, in case your wondered. Eclipse color-codes log messages based on their severity level.

日志拥有多个级别：``.d()``表示调试，``.e()``表示错误、``.w()``表示警告(warning)、``.i()``表示信息(info)。有趣的是，还有个``.wtf()``表示“不该发生的错误”，它的字面意思是“What a Terrible Failure”。Eclipse会按照不同的颜色显示不同级别的日志。

(译者注：在英文社区中，"WTF"是很常见的调侃用语，原意指"What The Fuck"。``.wtf()``这个方法可以视为Android框架的一个小幽默)

{WARNING}
% 	Eclipse’s Organize Imports tool can sometimes lead to hard-to-find problems. For example, if your project doesn’t have R.java generated (which could easily happen because there’s an earlier problem with one of XML resources) then Organize Imports will import android.R class. This other R class is part of Android framework and has the same name as your local R class, making it hard to notice. So, if you have many compilation errors around your references to R resources, check that android.R is not imported.

Eclipse的Organize Imports工具有时可能会造成难以查找的错误。比如，有时你的工程还没有生成R.java文件，Organize Imports工具就自动插入了一句import android.R，这是因为Android框架中也有个R类与你的R类重名。因此若看到R资源文件相关的编译错误，不妨检查下是不是把android.R也给import了。

%TALK: "which could easily happen because there’s an earlier problem with one of XML resources"含义未明，求助 -fleuria

{/WARNING}

=== LogCat ===

% The Android system log is outputted to LogCat. LogCat is a standardized system-wide logging mechanism. LogCat is readily available to all Java and C/C++ code. The developer can easily view the logs and filter their output based on severity, such as debug, info, warning, or error, or based on custom-defined tags. As with most things in Android development, there are two ways to view the LogCat: via Eclipse or via the command line.

Android系统中的日志都是输出到LogCat。它是一套标准的系统日志机制，可在Java或者C/C++中使用。通过它，开发者可以阅读/过滤程序中输出的日志。在Android开发中，访问LogCat有两种方式：通过Eclipse，或者通过命令行。

% === LogCat from Eclipse DDMS Perspective ===
===访问LogCat：通过Eclipse的DDMS===

% To view logcat in Eclipse, you need to open the LogCat View. [增加 (see Figure 6.6, “LogCat in Eclipse”).] It is typically available in DDMS perspective to which you can switch by clicking on DDMS in top-right corner of Eclipse [images/icon_ddms.png] or by going to Window→Open Perspective→DDMS in the Eclipse menu.

在Eclipse中访问LogCat，需要打开LogCat View，它一般在DDMS中。单击右上角的DDMS按钮[images/06-icon_ddms.png]，或者选择菜单Window→Open Perspective→DDMS。

% DDMS stands for Dalvik Debug Monitor Server. DDMS is the connection between your application running on the device and your development environment, such as Eclipse.

DDMS指Dalvik Debug Monitor Server，它可以将运行于设备上的应用程序与Eclipse这样的开发环境连接起来。

**图 6.6. Eclipse的LogCat**
	[images/06-logcat.png]

% You can define filters for LogCat as well. Click on the little green plus button and LogCat Filter dialog will come up.[增加 (see Figure 6.7, “LogCat Filter”)] You can define a filter based on TAG, severity, or process id. This will create another window within LogCat showing you only the log entries that match your filter.

可以在LogCat中设置过滤规则。单击绿色加号按钮，调出LogCat Filter对话框，然后就可以根据TAG、日志等级或进程id设置过滤规则了。过滤所得的结果显示在另一个窗口中。

**图 6.7. LogCat Filter**
	[images/06-logcat-filter.png]

{NOTE}
% 	DDMS may not show up for in the top right corner right away if you haven’t used it before. If that’s the case, go to Window→Open Perspective and choose DDMS there. From there on, it should show in your window tab as well.

如果你还没有使用过DDMS，那么Eclipse的右上角可能会没有它的按钮。出现这种情况的话，可以访问菜单Window→Open Perspective并选择DDMS。随后它的按钮就会显示出来了。
{/NOTE}

% === LogCat from command line ===
===访问LogCat：通过命令行===

% Just like all the tools, anything you can do in Eclipse, you can do from command line as well. To view logcat, open up your terminal window and type:

同前面的所有工具无异，Eclipse中可以做的，在命令行中也同样可以。访问LogCat，可以打开控制台，输入：

{CODE}
[user:~]> adb logcat
{/CODE}

% This will give you the tail of current logcat and will be updated as your device keeps generating log entries. You can also filter log entries on command line, but the syntax is not the most intuitive. To only see StatusActivity-tagged entries, you specify StatusActivity:*, meaning you want all severity levels for this tag. However, you also have to specify what you don’t want to see. To do that, you add *:S, meaning silence all other tags. The following command line illustrates that:

它可以显示出LogCat的最新输出，并在收到新日志时实时更新。你也可以过滤日志，只是它的语法可能没那么直观。比如想查看标记为StatusActivity的日志条目，就用``StatusActivity:*``作为过滤，其中的``*``表示接受所有级别的日志。当然也可以设置过滤将不希望见到的部分忽略，如``*:S``，表示不显示其它标志的日志。命令如下：

{CODE}
[user:~]> adb logcat StatusActivity:* *:S
{/CODE}

{TIP}
% 	I find it useful to keep a command line window open with adb logcat running in it at all times. This makes it easy for me to quickly see what’s going on with my app and is certainly much faster than switching to DDMS perspective in Eclipse.

个人经验，在开发中一直运行着一个adb logcat的命令行窗口是很有用的。这样可以方便地跟踪程序的状态，而且比起切换到Eclipse的DDMS界面，这要快的多。
{/TIP}

% == Threading in Android ==
==Android的线程机制==

% A thread is a sequence of instructions executed in order. Although each CPU can only process one instruction at a time, most operating systems are capable of handling multiple threads on multiple CPUs, or interleaving them on a single CPU. Different threads need different priorities, so the operating system determines how much time to give each one if they have to share a CPU.

一个线程就是一个连续的指令序列。每个CPU一次只能处理一条指令，不过大部分操作系统都支持在单个CPU中轮流执行多个线程，也支持在多个CPU中同时执行多个线程。不同的线程拥有不同的优先级，操作系统以此为依据，安排线程的调度。

% Android operating system is based on Linux and as such is fully capable of running multiple threads at the same time. However, you as application developer need to be aware how applications use threads in order to design your application properly.

Android操作系统建基于Linux，这就获得了多线程的支持。作为开发者要开发正确的程序，就需要对应用程序使用线程的方法有所了解。

% === Single Thread ===
===单线程===

% By default, an Android application runs on a single thread. Single threaded application run all commands in serially, meaning the next command is not completed until the previous one is done. Another way of saying the same thing is that each call is blocking.

Android程序默认运行在单线程之下。单线程顺序执行所有的操作，这一操作完成之前，下一个操作绝不会执行。这一行为被称作“阻塞”(blocking)。

**图 6.8. 单线程执行**
	[images/06-Threads-Single.png]

% This single thread is also known as the UI (as in User Interface) thread since that’s the thread that processes all the user interface commands as well. The UI thread is responsible for drawing all the elements on the screen as well as processing all the user events, such as touches of the screen, clicks on the button, and so on. [增加  Figure 6.8, “Single-threaded execution” shows the execution of our code on a single UI thread.]

这个线程也被称作UI线程，意思是程序中用户界面的相关操作都在这里执行。除处理所有UI元素的渲染之外，事件的响应也由它负责。比如触摸屏幕、点击按钮等等。

% The problem with running StatusActivity on the single thread is our network call to update the our status. As with all network calls, the time it takes to execute is outside of our control. Our call to twitter.updateStatus() is subject to all the network availability and latency issues. We don’t know if the user is on the super fast WiFi connection, or is using a much slower protocol to connect to the cloud. In other words, our application cannot respond until the network call is completed.

让StatusActivity在单线程中运行会遇到一个问题，那就是执行网络操作时，用户界面会响应不灵。这是因为阻塞在网络操作上的时间是不可预知的。我们不知道用户的网络接入方式是快速的WiFi，还是慢速的GPRS，因此在调用``twitter.updateStatus()``时，必须考虑延时的问题。

{NOTE}
%Android system will offer to kill any application that is not responding within a certain time period, typically around five seconds for activities. This is known as Application Not Responding dialog, or ANR for short.[增加 (see Figure 6.9, “Application Not Responding dialog”).]

程序若长时间无响应(一般是五秒)，Android系统会自动弹出一个对话框，询问是否将该程序所在的进程杀死。这个对话框就是Application Not Responding，简称ANR。
{/NOTE}

**图 6.9. Application Not Responding**
	[images/06-ANR.png]

% === Multithreaded Execution ===
===多线程执行===

% A much better solution is to have the potentially long operations run on a separate thread. When multiple tasks run on multiple threads at the same time, the operating system slices the available CPU so that no one task dominates the execution. The result is that appears that multiple tasks are running in parallel at the same time.

与在单线程中阻塞相比，更好的做法是让程序运行在多个线程之中。有系统负责分配CPU时间，几个线程仿佛在同一时刻同时运行。这样可以避免某线程独占计算资源。

**图 6.10. 多线程执行**
	[images/06-Threads-Multi.png]

% In our example, we could put the actual network call of updating our status in the cloud in a separate thread. That way our main UI thread will not block while we’re waiting for the network and the application will appear much more responsive. We tend to talk of the main thread as running in the foreground and the additional threads as running in the background. They’re really all equal in status, alternating execution on the device’s CPU, but from the point of view of the user, the main thread is in the foreground because it deals with the UI. [增加 Figure 6.10, “Multithreaded execution” shows the execution of our code’s two threads—the main UI thread, as well as the auxiliary thread we use to perform potentially long-running network calls.]

在例子中，我们将网络操作的相关代码放到独立的线程里面。这样我们的主线程可以避免阻塞在网络操作上，用户界面不会响应不灵。按惯例，我们一般认为主线程是运行于前台，而其它的线程都是运行于后台。这是因为前端的用户界面运行于主线程。但在调度上，它们都是平等的。

% There are multiple ways of accomplishing multithreading. Java has a class Thread that allows for many of these operations. We could certainly use any of the regular Java features to handle putting the network call in the background.

使用多线程的方法有很多，Java的Thread类是其中之一。使用Thread类，就是使用Java的原生特性。

% However, one of the problems that we’d run into by using standard Java Thread class is that another thread is not allowed to update the elements in the main UI thread. This make sense since to update the UI thread we would need to synchronize with the current state of its objects and that would be a job on its own.

但这里有一点，那就是Java线程不可以直接访问其它线程的私有数据，比如UI线程中的控件。这样考虑是为了避免一些同步问题。

%TALK: "This make sense since to update the UI thread we would need to synchronize with the current state of its objects and that would be a job on its own." 这句很别扭，上文意译为“这样可以避免一些同步问题”只说了前半句，丢失了一些意思。

% In addition to standard Java threading support, Android provides a utility class AsyncTask specifically designed for this purpose.

为弥补这点不足，也作为Java标准的线程机制的补充，Android提供了一个AsyncTask类。


=== AsyncTask === 

% AsyncTask is an Android mechanism created to aid in handling long operations that need to report to UI thread. To take advantage of this class, we need to crate a new subclass of AsyncTask and implement doInBackground(), onProgressUpdate(), and onPostExecute() methods. In other words, we are to fill out the blanks for what to do in the background, what to do when there’s some progress and what to do when done with this task.

既要避免长时间的阻塞，又要访问UI线程的私有数据，那该怎么办？使用Android内置的``AsyncTask``(异步任务)机制。要使用它，我们需要派生一个``AsyncTask``的子类，并覆盖``doInBackground()``与``onPostExecute()``两个方法。这两个方法里面分别对应后台执行的相关代码：任务进行时的操作，以及任务完成时的操作。

% We’ll extend our earlier example with an asynchronous posting to the cloud. The first part of the example [修改 Example 6.5, “StatusActivity.java, version 2”] is very similar to the code in Example 6.3, “StatusActivity.java, version 1” but it hands off the posting to the asynchronous thread. A new AsyncTask does the posting in the background.

例6.5是使用AsyncTask修改过的代码，实现异步发布到服务端。它的开头部分与例6.3相似，不同在于它是使用了异步任务，而非阻塞在网络操作上。

**Example 6.5. StatusActivity.java, version 2**

{CODE}
package com.marakana.yamba1;

import winterwell.jtwitter.Twitter;
import winterwell.jtwitter.TwitterException;
import android.app.Activity;
import android.os.AsyncTask;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

public class StatusActivity2 extends Activity implements OnClickListener {
  private static final String TAG = "StatusActivity";
  EditText editText;
  Button updateButton;
  Twitter twitter;

  /** Called when the activity is first created. */
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.status);

    // Find views
    editText = (EditText) findViewById(R.id.editText);
    updateButton = (Button) findViewById(R.id.buttonUpdate);
    updateButton.setOnClickListener(this);

    twitter = new Twitter("student", "password");
    twitter.setAPIRootUrl("http://yamba.marakana.com/api");
  }

  // Asynchronously posts to twitter
  class PostToTwitter extends AsyncTask<String, Integer, String> { // #{1}
    // Called to initiate the background activity
    @Override
    protected String doInBackground(String... statuses) { // #{2}
      try {
        Twitter.Status status = twitter.updateStatus(statuses[0]);
        return status.text;
      } catch (TwitterException e) {
        Log.e(TAG, e.toString());
        e.printStackTrace();
        return "Failed to post";
      }
    }

    // Called when there's a status to be updated
    @Override
    protected void onProgressUpdate(Integer... values) { // #{3}
      super.onProgressUpdate(values);
      // Not used in this case
    }

    // Called once the background activity has completed
    @Override
    protected void onPostExecute(String result) { // #{4}
      Toast.makeText(StatusActivity2.this, result, Toast.LENGTH_LONG).show();
    }
  }

  // Called when button is clicked
  public void onClick(View v) {
    String status = editText.getText().toString();
    new PostToTwitter().execute(status); // #{5}
    Log.d(TAG, "onClicked");
  }

}
{/CODE}

% + The PostToTwitter class in this case is an inner class of StatusActivity. It also subclasses AsyncTask. Notice the use of Java generics to describe the data types that this AsyncTask will use in its methods. We’ll refer to these three types below. The first data type is used by doInBackground, the second by onProgressUpdate, and the third by onPostExecute
% + doInBackground() is the callback that specifies the actual work to be done on the separate thread, as if it’s executing in the background. The argument String... is the first of the three data types that we defined in the list of generics for this inner class above. The fact that it’s followed by three dots indicates that this is an array of Strings and you have to declare it that way even though you want to pass only a single status.
% + onProgressUpdate() is called whenever there’s progress in the task execution. The progress should be reported from the doInBackground() call. In this case, we do not have a meaningful progress to report. In another example, such as file download for instance, this could report the percentage of completion or amount of data downloaded thus far. The actual data type, in this case Integer refers to the second argument in the generics definition of this class.
% + onPostExecute() is called when our task is completed. This is our callback method to update the user interface and tell the user that task is done. In this particular case, we are using Toast feature of Android UI to show a quick message on the screen. Notice that Toast uses makeText() static method to make the actual toast message. Also, do not forget the call show() on the toast, otherwise your message will never be displayed and there won’t even be any errors - a hard bug to find. The argument that this method gets is the value that doInBackground() returns, in this case a String. This also corresponds to the third generics datatype in the class definition.
% + Once we have out AsyncTask setup, we can use it. To use it, we simply instantiate it and call execute() on it. The argument that we pass in is what goes into doInBackground() call. Note that in this case we are passing a single String that is being converted into a String array in the actual method later on. This is the use of Java’s variable number of arguments feature.

+ ``PostToTwitter``是``StatusActivity``的内部类，也是``AsyncTask``的子类。留意后面的三个类型参数，它们决定着下面函数的类型：第一个类型参数与``doInBackground()``相关，第二个与``onPostExecute()``相关，第三个与``onPostExecute()``相关。
+ ``doInBackground()``是个回调方法，表示异步执行的网络操作，就像执行在后台一样。它的参数``String...``来自前面声明中的第一个类型参数，后面的三个``.``表示它接纳多个字符串作为参数，即使只用到一个字符串也必须如此。
+ ``onProgressUpdate()``在任务进度更新时触发，其中的“进度”由``doInBackground()``负责更新。一个应用样例是，下载工具显示已完成的百分比。但在这里没有显示进度信息的必要，因此留空。
+ ``onPostExecute()``在任务完成时触发。我们可以在这个回调方法里面更新用户界面，显示任务完成。这里使用了Android的Toast机制，在屏幕上弹出一条消息。创建Toast的静态方法是``makeText()``，但在创建一条Toast消息之后，还需要调用``show()``才能显示出来，对这点需要小心。另外``onPostExecute()``方法参数的类型与前面的第三个类型参数相关。
+ 设置``AsyncTask``完毕，接下来使用它：简单创建一个实例，然后调用``execute()``即可。它的参数会原样传给``doInBackground()``。留意，这是个可变参数，因此单个字符串会被转化为字符串数组的形式。


% At this point, when user clicks on Update Status button, our activity will create a separate thread using AsyncTask and place the actual network operation on that thread. When done, the AsyncTask will update the main UI thread by popping up a Toast message to tell the user that operation either succeeded or failed. This approach makes our application much more responsive and user should never get "Application Not Responding: Force Close or Wait" message again, as shown in Figure 6.9, “Application Not Responding”. [增加 At this point, our application looks like Figure 6.11, “StatusActivity, part 1” when running.]

到这里用户只要单击``Upate Status``按钮，Activity即可隐式地创建出一个独立的线程，在里面执行异步任务中的网络操作。到任务结束时，``AsyncTask``会弹出一个Toast显示任务的成功与否。这样可以避免应用程序长时间的阻塞，也可以避免用户见到讨厌的``Application Not Responding: Force Close or Wait``对话框。


**图 6.11. StatusActivity, 1**
	[images/06-StatusActivity-1.png]

%== Other UI Events ==
==其它UI事件==

% So far, you have seen how to handle the click events by implementing OnClickListener and providing the onClick() method so that when the button is clicked this method is invoked. Imagine that we want to provide a little counter telling user how many characters are still available on the input from the maximum of 140. To do that, we need another type of listener.

前面我们已经看过了通过实现一个``OnClickListener``提供``onClick()``从而捕获点击事件的方法。接下来思考下，输入框的最大字符限制是140，我们该怎样统计已输入字符的个数？这就需要用到另一个侦听器(Listener)。

% Android provids many different listeners for various events, such as touch, click, and so on. In this case, we’re going to use TextWatcher to watch for text changes on the edit text field. Steps for this listener are similar to the steps for OnClickListener and are similar to many other listeners.

Android为不同的事件(如触摸、点击等)提供了不同的侦听器。在这里，我们需要用到的是``TextWatcher``来监视文本框中文本的变化，步骤与``OnClickListener``大同小异。实际上，各种侦听器的用法都是很相似的。

% From users stand point, we’ll add another TextView to our layout to indicate the number of characters still available to type. This text will change color, from green to yellow and red as user approaches the limit.

从用户的角度来看，界面上多了一个TextView显示仍可输入的字符数。它的颜色会随着字数的减少而变化，从绿到黄，最后红色表示输入到达限制。

% From Java point of view, we’ll implement TextWatcher and attach it to our text field where the user is typing the actual text. The TextWatcher methods will be invoked as user changes the text and based on the amount of text entered we’ll update the counter. [增加 See Example 6.6, “res/layout/status2.xml”.]

从Java的角度来看，我们需要实现一个``TextWatcher``来监视文本框的变化。它会在用户更改文本的时候触发，并根据字数的变化更新计数器。

**Example 6.6. res/layout/status2.xml**
{CODE}
<?xml version="1.0" encoding="utf-8"?>
<!-- Main Layout of Status Activity -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:orientation="vertical" android:layout_width="fill_parent"
  android:layout_height="fill_parent">

  <!-- Title TextView-->
  <TextView android:layout_width="fill_parent"
    android:layout_height="wrap_content" android:gravity="center"
    android:text="@string/titleStatus" android:textSize="30sp"
    android:layout_margin="10dp" />

  <!-- Text Counter TextView #{1} -->
  <TextView android:layout_width="wrap_content"
    android:layout_height="wrap_content" android:layout_gravity="right"
    android:id="@+id/textCount" android:text="000"
    android:layout_marginRight="10dp" />

  <!-- Status EditText  -->
  <EditText android:layout_width="fill_parent"
    android:layout_height="fill_parent" android:layout_weight="1"
    android:hint="@string/hintText" android:id="@+id/editText"
    android:gravity="top|center_horizontal"></EditText>

  <!-- Update Button -->
  <Button android:layout_width="fill_parent"
    android:layout_height="wrap_content" android:text="@string/buttonUpdate"
    android:textSize="20sp" android:id="@+id/buttonUpdate"></Button>

</LinearLayout>
{/CODE}


% + New TextView that represents the count of how many characters are still available for user to type. We start at 140 and then go down as user enters text.
+ 显示仍可输入字符数的``TextView``。其初始值为``140``，随着用户输入的增加而减少。


% The following version of Status Activity [增加 shown in Example 6.7, “StatusActivity.java, final version”] implements the TextWatcher interface, and the new methods in this example appear at the end of the class. Initially the text of the counter is in green color to indicate we can keep on typing. As we approach the maximum, the text turns yellow and eventually becomes red to indicate we are beyond the maximum message size.

下面的``StatusActivity``实现了``TextWatcher``接口，新加入的方法列在后面。TextView初始为绿色，表示还可以继续输入；随着字数增长，它会变成黄色，表示字数接近上限；最后变成红色，表示已经达到了字数限制。

**Example 6.7. StatusActivity.java, final version**
{CODE}
package com.marakana.yamba1;

import winterwell.jtwitter.Twitter;
import winterwell.jtwitter.TwitterException;
import android.app.Activity;
import android.graphics.Color;
import android.os.AsyncTask;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

public class StatusActivity extends Activity implements OnClickListener,
    TextWatcher { // #{1}
  private static final String TAG = "StatusActivity";
  EditText editText;
  Button updateButton;
  Twitter twitter;
  TextView textCount; // #{2}

  /** Called when the activity is first created. */
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.status);

    // Find views
    editText = (EditText) findViewById(R.id.editText);
    updateButton = (Button) findViewById(R.id.buttonUpdate);
    updateButton.setOnClickListener(this);

    textCount = (TextView) findViewById(R.id.textCount); // #{3}
    textCount.setText(Integer.toString(140)); // #{4}
    textCount.setTextColor(Color.GREEN); // #{5}
    editText.addTextChangedListener(this); // #{6}

    twitter = new Twitter("student", "password");
    twitter.setAPIRootUrl("http://yamba.marakana.com/api");
  }

  // Called when button is clicked
  public void onClick(View v) {
    String status = editText.getText().toString();
    new PostToTwitter().execute(status);
    Log.d(TAG, "onClicked");
  }

  // Asynchronously posts to twitter
  class PostToTwitter extends AsyncTask<String, Integer, String> {
    // Called to initiate the background activity
    @Override
    protected String doInBackground(String... statuses) {
      try {
        Twitter.Status status = twitter.updateStatus(statuses[0]);
        return status.text;
      } catch (TwitterException e) {
        Log.e(TAG, e.toString());
        e.printStackTrace();
        return "Failed to post";
      }
    }

    // Called when there's a status to be updated
    @Override
    protected void onProgressUpdate(Integer... values) {
      super.onProgressUpdate(values);
      // Not used in this case
    }

    // Called once the background activity has completed
    @Override
    protected void onPostExecute(String result) {
      Toast.makeText(StatusActivity.this, result, Toast.LENGTH_LONG).show();
    }
  }

  // TextWatcher methods
  public void afterTextChanged(Editable statusText) { // #{7}
    int count = 140 - statusText.length(); // #{8}
    textCount.setText(Integer.toString(count));
    textCount.setTextColor(Color.GREEN); // #{9}
    if (count < 10)
      textCount.setTextColor(Color.YELLOW);
    if (count < 0)
      textCount.setTextColor(Color.RED);
  }

  public void beforeTextChanged(CharSequence s, int start, int count, int after) { // {#10}
  }

  public void onTextChanged(CharSequence s, int start, int before, int count) { // {#11}
  }

}
{/CODE}

% + We declare that StatusActivity now implements TextWatcher. This means we need to actually provide the implementation for this interface, which we do later on in this class.
% + textCount is our text view that we defined in the layout above [修改为 Example 6.6, “res/layout/status2.xml”.].
% + First, we need to find the textCount in the inflated layout.
% + We set the initial text to 140 since that’s the maximum length of a status message in our app. Note that TextView takes text as value, so we convert a number to text here.
% + The textCount field will dynamically change color based on how much text is left to type. In this case, we start with green. Notice that Color class is part of Android framework and not Java. In other words, we’re using android.graphics.Color and not java.awt.Color. Color.GREEN is one of the few colors defined as a constant in this class. More on colors in the next section.
% + Here we attach the TextWatcher to our editText field. In other words, editText will call TextWatcher instance, in this case this which refers to this object itself.
% + afterTextChanged() is one of the methods provided by the TextWatcher interface. This method is called whenever the text changes in the view that this TextWatcher is watching. In our case, whenever user changes the underlying text in editText, this method is invoked with the current text.
% + Here we do some math to figure out how many characters are left given the 140 character limit.
% + Next, based on the availability of the text, we update the color of the counter. So, if more than 10 characters are available, we are still in the green. Fewer than 10 means we are approaching the limit, thus yellow color. If we are pass the limit of 140 characters, the counter turns red.

% + This method is called just before the actual text replacement is completed. In this case, we don’t need this method, but as part of implementing the TextWatcher interface, we must provide its implementation, event though its empty.
% + Similarly, we are not using onTextChanged() in this case, but must provide its blank implementation. [增加 Figure 6.12, “StatusActivity, part 1” shows what the TextWatcher looks like in our application when running.]

+ 使``StatusActivity``实现``TextWatcher``接口，并在后面提供这个接口的实现。
+ ``textCount``是我们新加入的TextView。
+ 找到``textCount``的引用。
+ 设置初始值为``140``，表示最大字符数限制。留意TextView的值只能是字符串，因此执行类型转换。
+ ``textCount``会随着字符数的变化而改变颜色，在这里初始化为绿色。留意，颜色都是以常量的形式定义在Android的框架中，而不是Java类库的一部分。我们用的是``android.graphics.Color``，而不是``java.awt.Color``。Color.Green是这个对象中定义的一个常量。
+ 将``TextWatcher``绑定到文本框``editText``，``editText``在内容发生变化时，就会调用到``TextWatcher``的实例。
+ ``afterTextChanged()``是TextWatcher接口定义的一个方法。它在自己所监视的文本框的内容发生变化时触发，以当前的文本为参数。在这里，只要用户修改了自己的输入，它就会被触发一次。
+ 做点数学，计算出当前可输入的字符数。
+ 然后根据可输入的字符数，设置``textCount``的颜色。如果字符数大于10，就是绿色；大于零小于十，黄色；等于零，红色。
+ 在文本修改之前触发。我们并不需要这个方法，但它作为``TextWatcher``的一部分不可以省略，因此留空。
+ 同上，我们不需要这个方法，因此留空。


**图 6.12. StatusActivity, 2**
	[images/06-StatusActivity-2.png]


% == Adding Color & Graphics ==
==图片与色彩==

% Our application works well, but it’s a bit dull looking. A little bit of color and graphics could go along way. Android offers a lot of support to make your application snazzy. We’re going to see some basics here.

我们的程序运行良好，但它的外观仍略显粗糙，不太好看。这时可以利用Android的相关特性，为程序添加一些图片和色彩。

=== Adding Images ===

% For starters, we want to add a background to our screen. This background is going to be some kind of graphics file. In Android, most images go to a resource folder called drawable. You may notice that you already have three folders with such name:

先给界面加上背景图片。在Android中，多数图片都是放在一个名为``drawable``的资源目录中。可以留意，我们有三个这样的目录：

% - /res/drawable-hdpi for devices with high density screens
% - /res/drawable-mdpi for devices with medium density screens
% - /res/drawable-ldpi for devices with low density screens

- /res/drawable-hdpi 用于较高分辨率的设备
- /res/drawable-mdpi 用于中等分辨率的设备
- /res/drawable-ldpi 用于较低分辨率的设备

% We are going to create another drawable folder called just /res/drawable. To do that, right-click on the res folder and choose New→Folder. For name, enter drawable. You can now put your graphics that are independent of screen density in this folder. We’re going to assume you found some cool background graphics and that you saved it in there under the name background.png. While Android supports many different file formats, PNG is preferred since to the once-controversial GIF standard because PNG is lossless and doesn’t require any patent licenses.

我们新建另一个目录，名为``/res/drawable``。右键单击``res``目录，选择``New→Folder``，输入名称为``drawable``。然后把分辨率无关的图片都放在这里即可。假定你已经找到了不错的背景图，并保存为``background.png``。Android支持多种图片格式，但我们在这里优先选择PNG格式而非GIF，这是因为PNG是无损格式，而且不需要专利许可。

{TIP}
% 	While PNG officially stands for Portable Network Graphics, it is also commonly known as PNG’s Not Gif to reflect its departure from controversial GIF standard.

PNG官方的全称是``Portable Network Graphics``。它也常常被人称作``PNG's Not Gif``，从这里可以看出它与GIF的分道扬镳。
{/TIP}

% Remember that all resources are being "watched" by Eclipse, and the moment we put something in there, Eclipse will use Android SDK tools to update the R class automatically. That means that at this point, we’ll have a reference R.drawable.background available to us if we wanted to use this resource from Java. But we’re not.

留意，所有的资源文件都被Eclipse“监视”着，在我们加入新资源的同时，Eclipse就会利用Android SDK工具自动更新R类。像刚才我们新加入了一个图片，R类中就多了一项``R.drawablw.background``。随后就可以在Java中引用它了。

% We are going to update our status activity layout file res/layout/status.xml next. Our goal is to have this background be the background of the entire screen. To do that, we’ll update the top layout in our file and set it’s background to point to this new background PNG file. To do that, we have to open the status.xml layout. Now we have two ways of adding the background to the top layout.

不过我们不是在Java中引用它。要将背景图铺到整个界面上，就更改顶层布局，将它的背景置为这个新加入的PNG文件。接下来要修改的是``StatusActivity``的布局文件``res/layout/status.xml``。有两种方法：

% === Using WYSIWYG Editor In Eclipse ===
====使用Eclipse的所见即所得编辑器====

% One way is to do it using the WYSIWYG tool that Eclipse provides [增加  as shown in Figure 6.13, “Eclipse Graphical Layout Editor”]. In this tool, we need to first select the main layout. We may have hard time selecting it since many other components are in front of it. The red border tells you what view or layout is selected at a time.

第一种方法是使用Eclipse的所见即所得工具。使用它，我们需要先选择主布局。其中列的组件比较多，因此选起来可能会费些力气。红色边框表示当前选择的Layout或者View。

% Another way of selecting it is to open up your Outline view in Eclipse and selecting the top element there. This view may or may not be currently visible in your Eclipse, depending on how you arranged many windows that are available. One sure way to get Outline view is to go to Window→Show View→Outline and open it up that way. Once you get this view opened, you can select the top layout, in this case our LinearLayout. You will know it’s selected if a red border is around your entire activity.

选择的主布局另一种方式是使用Eclipse的Outline视图，选择顶层元素。Outline这个视图的显示与否，与你Eclipse中窗口的个人设置有关。保险的方式是选择``Window→Show View→Outline``，这一定可以打开它。进入这个视图，选择顶层布局，在这里是我们的``LinearLayout``。若有红色边框围着整个Activity，那就表示选择对了。

% Next, you want to open up the Properties view in Eclipse. Again, this view may already be opened or may not be. If it’s not visible as a window in Eclipse, go to Window→Show View→Other and under General section pick Properties. This will open up a view in which you can change various properties for this particular view.

接下来打开Eclipse的Properties视图。同Outline视图一样，它也不一定显示在外面。这时可以选择``Window→Show View→Other``，然后在``General``下选择Properties即可。这样可以打开一个视图，提供各种属性的设置。

% The property we want to modify is background. You can now click on the little … button which will bring up Reference Chooser dialog [增加 (see Figure 6.14, “Reference Chooser”)]. In this dialog, choose Drawable→background.

我们想要修改的属性是background。你可以点击``…``按钮打开Reference Chooser对话框，然后选择``Drawable→background``。

**图 6.13. Reference Chooser**
	[images/06-ReferenceChooser.png]

% This will set the background of your top layout to @drawable/background. As you recall, this is the way that one XML resource refers to another resource. In this case, our status.xml layout is referring to the background.png drawable. Notice that we do not use extensions when referring to other file resources. Android figures out best file format automatically, in case there are files with same name but of different extension.

这将为你的顶层布局设置背景为@drawable/background。这是一种在XML资源里引用另一个资源的方式。在本例中，我们的status.xml布局引用了background.png drawable。注意到我们没有在引用其他资源时使用扩展名。Android会在出现相同名字不同扩展名时，自动选择最合适的文件类型。

设置顶层布局的``background``属性为``@drawable/background``。回想下，这正是在资源文件中引用其它资源文件的方式。放在这里，就是``status.xml``引用了drawable中的``background.png``文件。留意在引用其它文件的时候，我们不需要写扩展名。遇到名字相同但扩展名不同时，Android会自动检查出最合适的扩展名。

**图 6.14. Eclipse Graphical Layout Editor**
	[images/06-LayoutWYSIWYGEditor.png]

% === Updating Directly in XML Code ===
====直接修改XML代码====

% Another approach is always to go straight into the XML code and make changes there. Remember that everything you can do with Eclipse tools, you can also do in plain text editor. To switch to XML code view, select the tab status.xml in the bottom of the window, next to Layout tab. This will open up your file with standard XML editor.

另一种办法是直接修改XML代码。记住，所有用Eclipse工具所做的事情，在纯文本编辑器内也能做。要切换到XML代码视图，选择窗口底部的标签页status.xml，在Layout标签页后。这将会用标准XML编辑器打开文件。

第二种办法是直接修改XML代码。记住，凡是Eclipse工具能做的事情，纯文本编辑器也都能做。在窗口底部，``Layout``标签之右，就是``status.xml``标签。选择它即可切换到XML的文本编辑器。

% In this case, to add background resource to our entire activity we simply add android:background="@drawable/background" to our to `<LinearLayout> element.

为整个Activity添加背景资源，我们只在``<LinearLayout>``中简单加上``android:background="@drawable/background"``即可。

% From now on, we’re going to be making changes in XML code directly since it’s much simpler to explain. Also, the WYSIWYG Editor can only do so much and often you run into its limitations.

相比使用所见即所得工具所需的步骤，直接修改XML显然要清晰的多。从现在开始，我们将直接修改XML代码，毕竟所见即所得的灵活性有限。

% === Adding Color ===
===设置颜色===

% We now have the background for the entire screen, but what about the actual text box that user types the text to? The current design is stock. We could improve on it by adding some color and transparency to it.

现在界面有了背景图，但是文本框呢？依然乏善可陈。接下来为它设置下颜色，同时添加透明效果。

% Android uses the standard RGB color set but it also optionally expands it with an Alpha channel. So, you can express color as RGB or ARGB where A is the amount of transparency, R is the amount of red, G is for green and B stands for blue color. The combination of these three colors and optional transparency gives you every conceivable color from white to black, and from opaque to fully transparent! That’s the whole point of ARGB. Of course, the granularity isn’t exactly what Monet would be happy with; each value has only 256 possibilities.

Android使用标准的RGB颜色，加上可选的Alpha项，你可以使用RGB或ARGB两种方式描述颜色。其中A表示透明度，R表示红色，G表示绿色，B表示蓝色。每个值都在0~255之间，通过它们的混合，即可调和出各种不同的颜色以及不同的透明度。颜色的数目是有限的，这一点可能会让莫奈这样的大画家不高兴，但对电子设备来说，这已经绰绰有余了。

% Amounts of each can be represented either as values between 0 and 255, or using Hexadecimal system as values between 0 and FF. So, the actual values values can be AARRGGBB where each letter can be replaced with a value between 0 and F. There’s also a shorter version ARGB where for each value, it is repeated so that each two digits are the same. For example, #3A9F is the same as #33AA99FF and corresponds to #33 for alpha, #AA for red, #99 for green and #FF for blue. Notice that we use # symbol in front of hexadecimal values to distinguish them from decimal values.

0到255之间的值，换成十六进制就是0到FF。表示颜色的话，一般还是十六进制用的多。格式是AARRGGBB，其中的每个字符都是0到F之间的数字。这一格式有一种简化形式，那就是ARGB，其中每个字符表示重复的两个字符。比如#3A9F与#33AA99FF相同，对应的Alpha为#33、红为#AA、绿为#99、蓝为#FF。可以留意这里的``#``号，它用来表示这是个十六进制数，与十进制做区别。

% So, we could update the background of our EditText element to be #cfff, which is somewhat transparent white color.

好，更新EditText的background属性为#cfff，表示背景色为半透明的白色。

% Next, we can also update the color of the title text by changing the textColor property for that TextView. A good color would be white, for example. One way to specify white would be #fff but another way would be to enter @android:color/white. The android: part of that statement refers to Android operating system set of resources, in this case a predefined color white. [增加  Example 6.8, “res/layout/status.xml” shows these new additions to our status.xml code.]

也可以修改``textColor``属性更改TextView的文本颜色。比如我们觉得白色不错，可以把它设置为``#fff``，也可以输入``@android:color/white``引用操作系统内置的资源定义，也就是白色。

**Example 6.8. res/layout/status.xml**
{CODE}
<?xml version="1.0" encoding="utf-8"?>

<!-- Main Layout of Status Activity -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:orientation="vertical" android:layout_width="fill_parent"
  android:layout_height="fill_parent" android:background="@drawable/background"><!-- #{1} -->

  <!-- Title TextView-->
  <TextView android:layout_width="fill_parent"
    android:layout_height="wrap_content" android:gravity="center"
    android:text="@string/titleStatus" android:textSize="30sp"
    android:layout_margin="10dp" android:textColor="@android:color/white" /><!-- #{2} -->

  <!-- Text Counter TextView -->
  <TextView android:layout_width="wrap_content"
    android:layout_height="wrap_content" android:layout_gravity="right"
    android:id="@+id/textCount" android:text="000"
    android:layout_marginRight="10dp" />

  <!-- Status EditText  -->
  <EditText android:layout_width="fill_parent"
    android:layout_height="fill_parent" android:layout_weight="1"
    android:hint="@string/hintText" android:id="@+id/editText"
    android:gravity="top|center_horizontal" android:background="#cfff" /><!-- #{3} -->

  <!-- Update Button -->
  <Button android:layout_width="fill_parent"
    android:layout_height="wrap_content" android:text="@string/buttonUpdate"
    android:textSize="20sp" android:id="@+id/buttonUpdate" />

</LinearLayout>
{/CODE}

% + We set the background of the main layout to point to background.png file in /res/drawable/ directory.
% + We set the color of the title text to point to color defined in system color resource white.
% + We set the background of the edit text area to be a transparent white by specifying #cfff for color using hexadecimal ARGB value.

+ 设置主布局的背景为/res/drawable/目录下的``background.png``。
+ 设置标题文本的颜色为系统资源定义中的白色。
+ 设置文本框的背景为透明白色，十六进制格式，也就是#cfff。

% At this point you’ve seen multiple ways to specify color of couple of different properties of various views in your activity. There are many properties and many different widgets that Android offers. You should be able to extrapolate from this how to set other properties and make your application UI look exactly the way you want.

到这里，我们已观察了设置View颜色的几种方法。Android为开发者提供了丰富的控件，它们的属性也数目繁多、功能各异，但道理都是相同的。要设置哪个控件的哪个属性，我们完全可以凭经验推断出来，这就是最小立异原则的一种体现。

%TALK: 上一段意译比较重，加了一句话。


% == Alternative Resources ==
==特定的资源文件==

% Android supports multiple competing sets of resources. For example, you could have multiple versions of strings.xml file or status.xml layout, or background.png image. The reason why you would want multiple versions of same resource is to have best version be used in given circumstances. We have discussed this in the section called “Adding Images”.

Android允许你提供多种资源文件。比如你可以提供不同版本的``strings.xml``、``status.xml``或者``background.png``，针对不同的情景选用不同的资源文件。

% Imagine that your application is used in another country with different language. In that case, you could provide strings.xml version specifically for that language. Or imagine that user runs your application on a different device, with different screen that has more pixels. In that case, you’d want versions of your images specific for this screen pixel density. Similarly, user may simply rotate the device from portrait to landscape mode. While our application will redraw properly, there are further enhancements we could do to the layout of the UI given orientation of the screen.

假如你想让外国人使用你的应用程序，但他们的语言不同。这时你可能希望提供一个特定语言的``strings.xml``文件。或者你想让自己的应用程序跑在某设备上，但它的分辨率不一样，这时你可能希望提供一个特定的图片来适应它的分辨率。同样，用户会旋转设备，从portrait模式切换到landscape模式，我们程序的布局也需要对此作出调整。

% Android provides for all these cases in an elegant way. Basically, you simply need to create alternative folders for specific constraints. For example, our standard layout files go into /res/layout folder. Well, if we wanted to provide an alternative layout to be used specifically in landscape mode, we’d simply create a new file /res/layout-land/status.xml. And if you wanted to provide translated version of your strings.xml file to be used for users that are in French part of Canada, you’d put it in file called res/values-fr-rCA/strings.xml.

针对以上的诸多情况，Android给出了一种优雅的解决方案：只需要把特定的资源文件放到另一个目录中即可。比如，我们默认的布局文件在``/res/layout``目录，如果为landscape模式提供单独布局，那就新建一个文件到``/res/layout-land/status.xml``。同样，如果我们想为加拿大的用户提供法语版本，那就新建一个文件到``res/values-fr-rCA/strings.xml``。

% As you see from these couple of examples, the way alternative resources work is by specifying the qualifiers in the name of the resource folder. In case of French Canadian strings, Android knows that the first qualifier -fr refers to language and second qualifier -rCA specifies that the region is Canada. In both cases, we use Two-letter ISO codes to specify the country. So in this case, if the user is in Quebec for instance, and her device is configured to favor French language, Android will look for string resources in /res/values-fr-rCA/strings.xml file. If it doesn’t find a specific resource, it will fall back to default /res/values/strings.xml file. Also, if the user in France, Android in this case will use default resource since our French Canadian qualifiers do not match French for France.

从上可知，备用资源文件以它的目录名作为标识。比如加拿大的法语版本那个例子，Android可以认出第一个标志符``-fr``指"法语"，第二个标志符``-rCA``指"加拿大"，而这两个标志符都是表示地区的ISO代码。这样，加拿大魁北克省的用户只要把语言设置为法语，Android就会选用``/res/values-fr-rCA/strings.xml``文件作为字符串资源。如果没有找到这个文件，则选用默认的``/res/values/strings.xml``文件。不过，即使用户在法国且语言是法语，它仍选用默认资源文件，因为标识符中的"加拿大"与"法国"不匹配。

(译者注：魁北克是加拿大唯一的法语省。)

% Using qualifiers you can create alternative resources for languages and regions, screen sizes and orientations, device input modes (touch screen, stylus), keyboard or no keyboard, and so on. But how do you know what this naming convention for resource folder names is? The easiest tool is to use the New Android XML File dialog in Eclipse [增加  (see Figure 6.15, “Alternative resources with New Android XML File dialog”).]. To open New Android File dialog, choose File→New…→Android XML File from the Eclipse menu.

通过这些标志符，你可以针对不同的语言、地域、屏幕尺寸与角度、设备交互模式(触摸屏、手写笔)、是否使用键盘等等情景，提供特定的资源文件。但是我们又怎么知道它们对应的命名规范呢？可以参照Eclipse的New Android XML File对话框，选择`` File→New…→Android XML File ``菜单即可。

**图 6.15. New Android XML File 对话框**
	[images/06-AlternativeResources.png]



% == Optimizing User Interface ==
==优化用户界面==

% User interface is one of the most expensive parts of a typical Android application. To create a simple screen, your application has to inflate the XML from resources. For each element, it has to create a new Java object and assign its properties to it. Then it needs to draw each widget on the screen. All this takes many computing cycles.

对一般的应用程序来讲，用户界面算是最耗时的部分了。即使界面再简单，也免不了解析XML、初始化每个控件、绘制整个界面等等诸多操作，其中的计算量是不可忽视的。

% Given all this, it is worth keeping in mind few optimization points. You may want to try to limit number of widgets you have on the screen. This is specially true when you are using nested layouts to achieve desired look. This can sometimes get out of control and if you are nesting unnecessary objects in a loop (say, displaying rows of data on the screen), then the number of widgets quickly explodes and your user interface becomes sluggish.

因此写代码时，对可优化的地方多花些心思是值得的。控件如果使用过多，对性能的影响是很大的。而使用嵌套的Layout时要尤其小心，因为这样一不小心就会让控件的使用变得不受约束，界面自然也容易变得笨重迟缓。

% Generally, you want your structure to be flat instead of deep. You can accomplish this by replacing nested layouts with relative layouts.

应尽量让界面元素的结构保持平整，而避免嵌套过深。若发现有嵌套的Layout，不妨尝试使用RelativeLayout重构一下。


=== Hierarchy Viewer ===

% There’s a very useful tool that ships with Android SDK called Hierarchy Viewer [增加  (see Figure 6.16, “Hierarchy Viewer”)]. Go ahead and start it - it is in your SDK/tools directory.

Android SKD提供了一个非常有用的工具，那就是Hierarchy Viewer。它在你的``SDK/tools``目录下，启动即可。

% Hierarchy Viewer allows you to attach to any Android device, emulator or physical phone. You can then introspect the structure of the current view. It shows you all the widgets currently loaded in memory, their relationship to each other, and all their properties. You can introspect not just your screens but screens of any application on your device. This is also a good way to see how some other applications are structured.

Hierarchy View可以用到任何Android设备、仿真器或者真机上。它能列出内存中的所有控件，展示它们之间的关系以及各自的属性，供你查看当前界面的结构。它对设备上运行的所有程序都有效，因此也是查看他人程序结构的好方法。

**图 6.16. Hierarchy Viewer**
	[images/06-HierarchyViewer.png]


% == Summary ==
== 总结 ==

% By the end of this section, you should have your application run and look like Figure 6.17, “StatusActivity”. It should also successfully post your tweets to your twitter account. You can verify it is working by logging into the online service of your choice that supports Twitter API, such as yamba.marakana.com using the same username/password as hard coded in the application.

到这里你可以运行Yamba，尝试向twitter发送消息，效果如 //图6.17// 所示。如果发送成功，即可在twitter的网站上见到这条消息。

**图 6.17. StatusActivity**
	[images/06-StatusActivity-3.png]

% The following [修改为 Figure 6.18, “Yamba completion”] illustrates what we have done so far as part of the design outlined in Figure 5.4, “Yamba Design Diagram”:

下图展示了我们目前的完成部分，完整图参见//图5.4//。

**图 6.18. Yamba 完成图**
	[images/06-Yamba-1.png]


