%
%
%
% =Preferences, File System, Options Menu, and Intents=
=首选项，文件系统，选项菜单以及Intent=

% In this chapter, you will learn how to create preferences for your application, how the file system is organized, and how to use intents and the options menu to jump from one activity to another.

本章我们讲解首选项功能的实现、文件系统的组织方式以及通过Intent与菜单实现界面切换的方法。

% ==Preferences==
==首选项==

% Preferences are user-specific settings for an application. Preferences usually consist of some configuration data as well as a user interface to manipulate that data.

首选项即用户所做的个人设置。它包含一些选项数据，以及一个修改这些选项数据的用户界面。

% From user interface point of view preferences can be simple text values, checkboxes, selections from a pull-down menu, or similar. From data point of view, preferences is a collection of name-value pairs, also known as key-value or attribute-value pairs. The values are basic data types, such as integers, booleans, strings, and similar.

在用户看来，首选项就是一些文本框、复选框、下拉菜单等等组成的集合体；而在程序员看来，首选项是一组键值对构成的数据集，其中的值可以是整型、布尔型、字符串等等。

% Our micro-blogging applications needs to connect to specific server in the cloud using specific user account information. For that, Yamba needs to know username and password for that account as well as the URL of the server it’s connecting to. This URL is also knowns as API root. So, in our case, we’ll have three fields where user can enter and edit username, password and API root. This data will be stored as strings.

我们的微博应用需要连接到服务端，因此用户的用户名与密码自是必须，除此还需要知道服务端的URL(或者叫API root)。可知我们在这里需要提供三个选项条目，而且都是作为字符串存储。

% To enable our app to handle user-specific preferences, we’d have to build a screen to enter the information, a Java code to validate and process that information, and some kind of storage mechanism to store this information.

为应用添加首选项功能，我们的工作就是实现一个输入选项数据的界面，编写Java代码验证并处理数据，以及引入某种存储机制。

% While all this sounds like a lot of work, Android provides a framework to help streamline working with user preferences. First, we’ll define what our preference data looks like in a Preference resource file.

% The steps to creating preferences for our application will be to:

听起来像是工作量不少，不过有Android提供的框架可用，我们的工作可以大大简化为如下几个步骤：

% + Create Preference resource file prefs.xml.
% + Implement PrefsActivity.java file that inflates that resource file.
% + Register this new activity with the AndroidManifest.xml file.
% + Provide a way to start that activity from the rest of the application.

+ 创建首选项的资源文件``prefs.xml``。
+ 对应这个资源文件，再PrefsActivity.java中实现一个Activiy。
+ 将这个Activity注册到``AndroidManifest.xml``。
+ 提供一个访问这个Activity的方法。


===资源文件===

% We are going to start by creating the prefs.xml - a resource file that outlines what our preference screen will look like. The easiest way to create it would be to use New Android XML File tool in Eclipse [增加 , as shown in Figure 7.1, “New Android XML File”.]. To start the New Android XML File dialog, go to File→New→Android XML File, or click on the little a+ icon in the top menu bar of Eclipse: [images/a-plus.png] 

首先创建一个资源文件``prefs.xml``——它用来声明首选项界面的内容。创建它的最简单方法就是使用Eclipse的New Android XML工具：可以选择File→New→Android XML File，也可以点击菜单栏上的[images/a-plus.png]按钮。

**图 7.1. New Android XML File**

[images/07-NewAndroidXMLFile.png]

% The key is to give the new file the name, in this case prefs.xml and to choose Preference for the type of resource. The tool should automatically suggest that this new file should be created in /res/xml folder and that the root element for the XML file should be PreferenceScreen. Just like discussed before in the section called “Alternative Resources”, we could create alternative versions of this same resource by applying various qualifiers such as screen size and orientation, language and region, etc.

输入文件的名字，也就是``prefs.xml``，选择资源类型为Preference。工具缺省将文件放在``/res/xml``目录下边，且其根节点为``PreferenceScreen``。前面``Alternative Resources``一节中提到，我们可以为同一资源设置多个不同的资源文件，以适应不同的屏幕尺寸、语言及区域等参数的需要。

{NOTE}
% We’re using Eclipse tools where applicable to get the job done quicker. If you were to use another tool, you’d have to create this file manually and put it in the right folder.

在这里我们通过Eclipse的辅助工具简化了工作。如果使用其它工具，可能就需要手工创建这个文件并将其置于合适的目录之下。
{/NOTE}

% Once you click on Finish, Eclipse will create a new file for you and open it up. Eclipse typically opens the XML files it knows about in its developer-friendly view.

点击``Finish``，Eclipse即可创建出这个文件，同时打开一个开发者友好的界面，允许你编辑它。

% In this view, you can create the username preference entry by selecting PreferenceScreen on the left, and then choosing Add→EditTextPreference On the right hand side, expand Attributes from Preferences section. Eclipse will offer you number of attributes to set for this EditTextPreference.

在这个界面中，选择左边的``PreferenceScreen``，然后``Add→EditTextPreference``，这就可以为``username``创建对应的选项条目了。展开右边``Preference``下边的``Attributes``，可以见到``EditTextPreference``的诸多属性。

% Not all attributes are equally important. Typically, you will care about the following:

属性有很多，但是我们关心的一般也只有如下几个：

% Key
%       A unique identifier for each preference item. This is how we’ll look up particular preference later.
% Title
%       The name of this preference that user will see. It should be a short name that fits on a single line of the preference screen.
% Summary
%       A short description of this preference item. This is optional but highly recommended.

: Key
  每个选项条目的唯一标识符。用以获取相应选项条目的引用。
: Title
  用户见到的选项名称。长度不要超过屏幕的一行。
: Summary
  针对这个选项条目的简介信息。此项可选，但强烈建议提供上。


% username preference, we’ll put username for key. We will define Title and Summary in strings.xml as this is the best practice.

对username一项而言，key就是``username``。至于Title与Summary的值，我们都放在``string.xml``里面，这是个好习惯。

% Instead of modifying strings.xml file directly, you can use an Eclipse shortcut. Here’s how it goes:

编辑``string.xml``也可以使用Eclipse提供的辅助工具。步骤如下：

% + Click on Browse and select New String…. This will open a dialog to create a new string resource.
% + Enter titleUsername for R.string. value and Username for String value.
% + Click Ok and this will insert a new string resource in strings.xml resource.
% + You can now pick that value from the list of resources.

+ 单击Browse，选择``New String...``，打开新建string资源的对话框。
+ 为R.string输入``titleUsername``，为String输入``Username``。
+ 单击Ok，即可在``strings.xml``中插入一条新的string资源。
+ 随后就可以在资源列表中取出来引用它了。


% The above describes how to add Username preference item. You can now repeat the same steps for Password and API Root items.

如上即为创建``Username``选项条目的步骤。对//Password//及//API Root//两项同理。

% To switch to the actual XML code by clicking on the tab on the bottom of this window: [增加  shown in Figure 7.2, “Prefs.xml in developer-friendly view”.]

要查看实际的xml代码，可以单击窗口底下的标签。

**图 7.2. Prefs.xml 的图形化编辑界面**

[images/07-prefs_xml.png]

% [增加 The raw XML for the preference resource looks like the code shown in Example 7.1, “res/xml/prefs.xml”.]

它的内容大致如下：

**Example 7.1. res/xml/prefs.xml**
{CODE}
<?xml version="1.0" encoding="utf-8"?>
<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">

  <EditTextPreference android:title="@string/titleUsername"
    android:summary="@string/summaryUsername" android:key="username"></EditTextPreference>

  <EditTextPreference android:title="@string/titlePassword"
    android:password="true" android:summary="@string/summaryPassword"
    android:key="password"></EditTextPreference>

  <EditTextPreference android:title="@string/titleApiRoot"
    android:summary="@string/summaryApiRoot" android:key="apiRoot"></EditTextPreference>

</PreferenceScreen>
{/CODE}

% <PreferenceScreen> is the root element that defines our main preference screen. It has three children, all <EditTextPreference>. This is simply a piece of editable text. Other common elements here could be <CheckBoxPreference>, <ListPreference>, and so on.

<PreferenceScreen>是定义首选项界面的根节点。它下面有三个子元素，皆为<EditTextPreference>，也就都是文本框。常见的元素还有<CheckBoxPreference>，<ListPreference>等等。

% The main property of any of these elements is the key. The key is how we’ll look up these values later on. Remember, preferences is just a set of name-value pairs at the end of the day.

以上最重要的属性就是key了，它是获取对应的配置数据所必需的标识符。前面提到，首选项正是一组键值对(Key-Value Pair)构成的数据集。

% Like we said couple of times earlier, while Eclipse does provide a developer-friendly tools to manage XML files, you often run into certain limitations with with Eclipse. For example, we would like to hide the actual text that the user types in the password field as it’s commonly done with passwords. Android does provide support for that but Eclipse tools haven’t integrated it in there yet. Since we can always edit the XML directly, in this case we to that to add android:password="true" property to our password property. This will cause the password to be masked while user is typing it in.

如前所说，编辑XML有Eclipse提供的辅助工具可用，它们界面友好，使用方便，但有时这也限制了灵活性。比如按照惯例，我们一般希望在密码一栏中隐藏数据的输入，Android也提供了这一功能的支持，但是Eclipse中的工具还没有跟上。这时就需要手工修改XML了，为password元素添加一个属性``android:password="true"``即可。

===PrefsActivity===

% Now that we have the preferences defined in their own XML resource file, we can create the activity to display these preferences. You may recall from <<Activities> that every screen in an Android app is an activity. So, to display the screen where user enters username and password for their online account, we’ll create an activity to handle that screen. This activity will be a special preference-aware activity.

对应首选项的XML资源文件已定义完毕，接下来为它创建一个界面。回想下，我们曾在 //第六章// 提到，Android程序中的任何界面都是Activity。用户需要修改选项的界面，我们就必须专门新建一个Activity。

% To create an activity, we create a new Java class. To do so, in Eclipse, select your package under your src folder, right-click on the package and select New→Class. A New Java Class window will pop up. You just need to enter PrefsActivity for the Name and click Finish. This will create PrefsActivity.java file under your package in your source folder.

创建Activity对应的类。在Eclipse中进入你的package，右键选择New→Class。在出现的``New Java Class``窗口中设置名字为``PrefsActivity``，点击Finish即可在项目中新建一个PrefsActivity.java文件。

% Our PrefsActivity class [增加 shown in Example 7.2, “PrefsActivity.java”] going to be a very simple Java file. This is because we inherit from PreferenceActivity, an Android framework provided class that knows how to handle preferences.

为简化首选项界面的开发，Android框架提供了一个``PreferenceActivity``类。以它为基类，我们的类可以很简单。

**Example 7.2. PrefsActivity.java**
{CODE}
package com.marakana.yamba2;

import android.os.Bundle;
import android.preference.PreferenceActivity;

public class PrefsActivity extends PreferenceActivity { // #{1}

  @Override
  protected void onCreate(Bundle savedInstanceState) { // #{2}
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.prefs); // #{3}
  }

}
{/CODE}

% + Unlike regular activities, PrefsActivity will subclass (i.e. extend) PreferenceActivity class.
% + Just like any other activity, we override onCreate() method to initialize the activity.
% + Unlike regular activities that usually call setContentView(), preference activity will set its content from the prefs.xml file via a call to addPreferencesFromResource().

+ 与一般的Activity不同，PrefsActivity以``PreferenceActivity``为基类。
+ 覆盖``onCreate()``方法，做些初始化工作，这点同其它Activity一样。
+ 与其它Activity通常会调用``setContentView()``不同，这里通过调用``addPreferencesFromResource()``装载``prefs.xml``中定义的内容。


{TIP}
% If you didn’t want to type the long signature of onCreate() and other methods that we often have to implement or override, you could use an Eclipse tool to help you with that. While in your PrefsActivity.java and after you have added ... extends PreferenceActivity..., you can choose Source→Override/Implement Methods…. This will bring up a dialog box with appropriate selection of methods you could override or implement given that you are subclassing PreferenceActivity class. In here, you can choose onCreate() and Eclipse will insert the stub for this method into your code.

在覆盖方法时，如果不想打字敲出``onCreate()``或其它方法那长长的声明，大可使用Eclipse的工具代劳。假如你在编辑``PrefsActivity.java``文件，并已加上了``extends PreferenceActivity``。那就可以选择`` Source→Override/Implement Methods…``，然后会出现一个对话框，在里面选出需要覆盖的方法(这里是``onCreate()``)即可。Eclipse会为你选择的方法生成代码。
{/TIP}

% ===Update Manifest File===
===修改Manifest文件===

% Whenever we create one of these main building blocks (Activities, Services, Broadcast Receivers, Content Providers) we need to define them in AndroidManifest.xml file. In this case, we have a new PrefsActivity and we must add it to the manifest file.

无论何时，只要新建了基本构件(Activity,Service,BroadcastReceiver,ContentProvider)就要修改Manifest文件，添加相应的声明。在这里，我们需要将``PrefsActivity``注册到Manifest文件。

% Just like with any Android XML file, opening AndroidManifest.xml in Eclipse will typically bring up the developer-friendly view of that file. In this file, you could choose Application tab, then under Application Nodes choose Add→Activity and for its Name type .PrefsActivity.

同前面一样，在Eclipse中打开XML文件会默认进入Eclipse提供的图形化编辑界面。选择Application标签，然后在Application节点之下，选择``Add→Activity``，输入Name为``.PrefsActivity``。

% However, we can also do this straight from the raw XML by clicking on AndroidManifest.xml tab on the bottom of this window. I find that while Eclipse is useful when it comes to creating XML files, often editing raw XML is faster and gives you much more control.

当然也可以进入下边的``AndroidManifest.xml``标签直接修改XML代码。个人观感，通过Eclipse工具可以很方便地生成XML文件，而直接编辑XML代码往往速度更快，也更加灵活。

{TIP}
% When editing code in Eclipse, you can use Ctrl+Space key shortcut to invoke type-ahead feature of Eclipse. This is every useful both for XML and Java code and is context-sensitive, meaning Eclipse is smart enough to know what could possibly be entered at that point in code. Using Ctrl+Space makes your life as programmer much easier as you don’t have to remember long method names and tags, plus it helps avoid typos.

在Eclipse中编辑代码时，可以使用Ctrl+Space快捷键调出Eclipse的自动完成功能。Eclipse可以感知出当前输入代码的上下文，从而预测接下来可能输入的内容。这一来程序员即可省去牢记各种方法变量的名字，也可以减少输入错误，对生产力的提高是大有好处的。
{/TIP}

% So after adding our manifest file now looks like this: [修改为 the code shown in Example 7.3, “AndroidManifest.xml”.]

修改后的Manifest大致如下：

**Example 7.3. AndroidManifest.xml**
{CODE}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  android:versionCode="1" android:versionName="1.0" package="com.marakana.yamba2">
  <application android:icon="@drawable/icon" android:label="@string/app_name">

    <activity android:name=".StatusActivity" android:label="@string/titleStatus">
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
    </activity>

    <activity android:name=".PrefsActivity" android:label="@string/titlePrefs" /> <!-- #{1} -->

  </application>
  <uses-sdk android:minSdkVersion="4" />

  <uses-permission android:name="android.permission.INTERNET" />
</manifest>
{/CODE}

% + Defines the new PrefsActivity.

+ 新加入的PrefsActivity的声明。


% We now have a new preference activity, but no good way of getting to it yet. We need a way to launch this new activity. For that, we use options menu.

现在我们已经实现了首选项界面，但仍没有办法访问它。因此在下面引入选项菜单(Options Menu)。


% ==Options Menu==
==选项菜单==

% Options menu is an Android user interface component that provides standardized menus to applications. The menus appear at the bottom of the screen when the user presses Menu button on the device.

选项菜单是Android程序中标准的菜单组件。只要用户按下设备的菜单按钮，它就可以从屏幕下方显示出来。

% To add support for options menu to an application, we need to do the following:

为程序添加选项菜单，我们需要：

% + Create menu.xml resource where we specify what the menu consists of.
% + Add onCreateOptionsMenu() to the activity that we want to provide this menu. This is where we inflate the menu.xml resource.
% + Provide handling of menu events in onOptionsItemSelected().

+ 新建一个``menu.xml``表示菜单的内容。
+ 在菜单所在的Activity中添加一个方法``onCreateOptionsMenu()``，在里面装载``menu.xml``中的内容。
+ 在``onOptionsItemSelected()``中响应菜单的事件。


% ===Menu Resource===
===菜单的资源文件===

% We start by defining the menus in an XML resource for the options menu. Just like with other Android XML files, we can use the little a+ icon in the Eclipse toolbar or choose File→New…→Android XML to launch New Android XML File dialog. In this dialog, for File enter menu.xml and for Type select Menu. Click Finish button and Eclipse will create a new folder /res/menu with menu.xml file in it. It will also open this file in developer-friendly view. [增加 (see Figure 7.3, “Menu.xml in developer-friendly view”).]

先为选项菜单新建一个XML资源文件。同新建其它XML文件的流程一样，单击Eclipse工具栏的``a+``按钮或者选择``File→New…→Android XML``，打开New Android File对话框，在File一栏输入``menu.xml``，选Type为``Menu``，然后点击Finish，Eclipse即可在``/res/menu``目录下创建出一个新文件``menu.xml``，同时打开一个图形化的编辑界面。

% In this view, you can click on Add→Item. This will add a new menu item to your menu. In the Attributes section on the right, you can see over a dozen various attributes that we can set for this menu item. Just like before, not all attributes are equally important.

在这个界面中，点击``Add→Item``即可为菜单新建一条菜单项。右边的Attributes列出了可供编辑的诸多属性。同前面一样，重要的只有部分几个：

**Id**
% The unique identifier of this resource. Just as when we designed the layout in Chapter 6, Android User Interface, this identifier is typically of form @+id/someId where someId is the name that you give it. This name should contain only letters, numbers and underscore.

菜单项的唯一标识符。第六章曾提到，标识符一般都是``@+id/someId``这样的格式。其中``someId``是你提供的名字，只能由字母、数字和下划线组成。

**Title**
% The tile of this menu as it will appear when displayed. Keep in mind that space on the screen is typically limited so keep the title short. Alternatively, you can provide Title condensed attribute for shorter version of the title that will be shown instead of Title if space is limited. Just like before, best practice is to define the actual text value of the title in strings.xml resource and just reference it here.

菜单项显示的标题。留意屏幕的宽度往往是有限的，因此标题应尽量的短。好习惯是，在此引用``string.xml``中定义的内容。

**Icon**
% The icon that shows along with the menu item’s title. While is is not required, it is a very useful visual cue from usability point of view. However, in this case it illustrates how to point to Android system resources.

% The next section describes these resources in more detail.

显示在菜单项上的图标。这不是必须的，但是加上对用户体验有好处。在这里，我们拿它作为例子，展示引用Android系统资源的方法。而具体细节将在下一节讨论。


% ===Android System Resources===
===Android系统资源===

% Just like your application can have its resources so can Android system as well. Like most other operating systems, Android comes with some preloaded images, graphics, sound clips, and other types of resources. Recall that our app resources are in /res/. To refer to Android system resources prefix them with with android: keyword in XML, for example @android:drawable/ic_menu_preferences. If you are referring to an Android system resource from Java, then you use android.R instead the usual R reference.

我们的程序都有自己的资源，Android系统也同样。Android系统中内置了许多图标、图像、音频等等各种资源文件。回想下，应用程序的资源文件都在/res/目录之下，要在XML中引用它们，只需填上地址即可；而引用系统资源，则需要为地址加一个前缀``android:``，比如``@android:drawable/ic_menu_preferences``。在Java中引用的话，就用android.R替换掉原先的R。 

{TIP}
% The actual resource files are in your SDK, inside specific platform folder. For example, if you are using Android 9 (Gingerbread), the location of the resource folder would be android-sdk/platforms/android-9/data/res/.

系统的资源文件都位于SDK中，与平台相关。比如你使用Android 9 (Gingerbread)，那它的实际地址就在``android-sdk/platforms/android-9/data/res/``。
{/TIP}

**图 7.3. Menu.xml的图形化编辑界面**

[images/07-menu_xml.png]

% The raw XML of menu.xml is shown here: [修改为 in Example 7.4, “res/menu/menu.xml”.]

``menu.xml``的源码如下：

**Example 7.4. res/menu/menu.xml**
{CODE}
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
  <item android:id="@+id/itemPrefs" android:title="@string/titlePrefs"
    android:icon="@android:drawable/ic_menu_preferences"></item>
</menu>
{/CODE}

% As you can see, there’s just one <item> element within our <menu> element making this a single menu item menu.

可见<menu>标签下只有一个<item>标签，表示菜单中只有一个菜单条目。


% ===Update StatusActivity to Load Menu===
===更新StatusActivity，装载菜单===

% Recall that the options menu is loaded by your activity when user clicks on the Menu button on the device. First time menu button is pressed, system will call activity’s onCreateOptionsMenu() method to inflate the menu from the menu.xml resource. This process is similar to inflating user interface from layout resources that we discussed in the section called “StatusActivity Java Class”. Basically, the inflater reads the XML code and for every element, it creates a corresponding Java object and for each attribute in XML is sets that object’s properties accordingly.

前面提到，菜单是在用户按下设备的菜单按钮时打开。在用户第一次按下菜单按钮时，系统会触发Activity的``onCreateOptionsMenu()``方法，在这里装载``menu.xml``文件中表示的菜单。这与第六章``StatusActivity类``中为Activity装载布局文件的做法有些相似。都是读取XML文件，为其中的每个XML元素创建一个Java对象，并按照XML元素的属性初始化对象。

% From that point on, the menu is in memory and onCreateOptionsMenu() doesn’t get called again until the activity is destroyed. Each time user selects a menu item though, onOptionsItemSelected() gets called to process that click. We’ll talk about this in the next section.

可以看出，只要Activity不被销毁，``onCreateOptionsMenu()``最多只会被触发一次。当用户选择某菜单项时，会触发``onOptionsItemSelected``，这在下一节讨论。

% We need to update the StatusActivity to load up the options menu. To do that, add onCreateOptionsMenu() method to StatusActivity. This method gets called only first time when user clicks on the menu button.

我们需要为Activity加入装载菜单的相关代码，为此加入``onCreateOptionsMenu()``方法。它将只在用户第一次按下菜单键时触发。

{CODE}
// Called first time user clicks on the menu button
@Override
public boolean onCreateOptionsMenu(Menu menu) {
  MenuInflater inflater = getMenuInflater();   // #{1} 
  inflater.inflate(R.menu.menu, menu);         // #{2}
  return true; // #{3}
}
{/CODE}

% + We get the MenuInflater object from the context.
% + Use the inflater to inflate the menu from the XML resource.
% + We must return true for this menu to be displayed.

+ 获取MenuInflater对象。
+ 使用inflater对象装载XML资源文件。
+ 要让菜单显示出来，必须返回True。


% ===Update StatusActivity to Handle Menu Events===
===更新StatusActivity，捕获菜单事件===

% We also need a way to handle various clicks on the menu items. To do that, we add another callback method, onOptionsItemSelected(). This method is called every time user clicks on a menu item.

我们还需要捕获菜单条目的点击事件。为此添加另一个回调方法，``onOptionsItemSelected()``。它在用户单击一个菜单条目时触发。

{CODE}
// Called when an options item is clicked
@Override
public boolean onOptionsItemSelected(MenuItem item) {
  switch (item.getItemId()) {                              // #{1}
  case R.id.itemPrefs:
    startActivity(new Intent(this, PrefsActivity.class));  // #{2}
  break;
  }

  return true;  // #{3}
}
{/CODE}

% + Since the same method is called regardless which item user clicked on, we need to figure out the id of that item and based on that switch to a specific case to handle each item. At this point, we only have one menu item, but that might change in the future. Switching on item ID is a very scalable approach and will adapt nicely as our application grows in complexity.
% + startActivity() method in context allows us to launch a new activity. In this case, we are creating a new intent specifying to start PrefsActivity class.
% + Return true to consume the event here.

+ 此方法在任意菜单条目被点击时都会触发，因此我们需要根据不同的条目ID做不同的处理。暂时这里只有一个菜单条目。不过随着程序复杂度的增长，需要添加新条目的时候，这样也是非常容易扩展的。
+ ``startActivity()``方法允许我们打开一个新的Activity。在这里，我们创建一条新的Intent，表示打开``PrefsActivity``。
+ 返回true，表示事件处理成功。
    

{TIP}
% Just like before, you could use Eclipse shortcut Source→Override/Implement Methods to add both onCreateOptionsMenu() and onOptionsItemSelected().

同原先一样，可以使用Eclipse的快捷功能``Source→Override/Implement Methods``生成``onCreateOptionsMenu()``、``onOptionsItemSelected()``方法的声明。
{/TIP}

% ===Strings Resource===
===字符串资源===

% Our updated strings.xml now looks like this [修改为 the code shown in Example 7.5, “res/values/strings.xml”.]:

更新后的``strings.xml``大致如下：

**Example 7.5. res/values/strings.xml**
{CODE}
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <string name="app_name">Yamba 2</string>
  <string name="titleYamba">Yamba 2</string>

  <string name="hintText">Please enter your 140-character status</string>
  <string name="buttonUpdate">Update</string>

  <string name="titleStatus">Status Update</string>
  <string name="titlePrefs">Prefs</string>
  <string name="titleUsername">Username</string>
  <string name="titlePassword">Password</string>
  <string name="titleApiRoot">API Root</string>

  <string name="summaryUsername">Please enter your username</string>
  <string name="summaryPassword">Please enter your password</string>
  <string name="summaryApiRoot">URL of Root API for your service</string>
</resources>
{/CODE}

% You should be able to run your application at this point and and see the new PrefsActivity by clicking on Menu→Prefs in StatusActivity [增加 (see Figure 7.4, “PrefsActivity”)]. Try changing your username and password, then reboot your phone, restart the app, and verify that the information is still there.

到这里，你已经可以查看新的选项界面了。打开程序，在消息界面中选择Menu→Prefs即可。不妨尝试更改用户名与密码的设置再重启应用程序，查看选项信息是否依然存在。

**图 7.4. PrefsActivity**

[images/07-PrefsActivity-1.png]


% ==Shared Preferences==
==SharedPreferences==

% Now that we have Preference Activity, and a way to save our username, password and the API root, it is time to make use of it. To programmatically access your preferences, we’ll use SharedPreference class provided by the Android framework.

已经有了选项界面，也有了存储用户名、密码、API root等选项信息的办法，剩下的就是读取选项信息了。要访问选项信息的内容，就使用Android框架的``SharedPreference``类。

% The fact that this class is called SharedPreference refers to the fact that this preference is easily accessible from anywhere in this application. So, any component of an Android application, such as Activities, Services, Broadcast Receivers, and Content Providers.

这个类允许我们在程序的任何部分(比如Activity,Service,BroadcastReceiver,ContentProvider)中访问选项信息，这也正是SharedPreference这个名字的由来。

% In StatusActivity, add definition for prefs object globally to the class:

在StatusActivity中新加入一个成员prefs：

{CODE}
 SharedPreferences prefs;
{/CODE}

% Now, to get the preference object, add the following to onCreate():

然后在onCreate()中添加一段代码，获取SharedPreferences对象的引用。

{CODE}
@Override
public void onCreate(Bundle savedInstanceState) {
        ...
        // Setup preferences
        prefs = PreferenceManager.getDefaultSharedPreferences(this); // #{1}
        prefs.registerOnSharedPreferenceChangeListener(this);   // #{2}
}
{/CODE}

% + Each application has its own shared preferences that all components of this application context share. To get the instance of this SharedPreferences, we use PreferenceManager.getDefaultSharedPreferences() and pass it this as the current context for this app. The name "shared" could be confusing - it means that this preference object contains data that is shared by various parts of this application only. It doesn’t mean any of this data is shared with any other application.
% + Preferences can and do change by the user. So we need a mechanism to notify this activity that old values are stale. To do that, we register this, meaning our StatusActivity with our shared preferences. For this to work, we’ll need to add ...implements OnSharedPreferenceChangeListener to our class definition as well as implement the required onSharedPreferenceChanged() method. This method will be explained in a bit.

+ 每个程序都有自己唯一的SharedPreferences对象，可供当前上下文中所有的构件访问。我们可以通过``PreferenceManager.getDefaultSharedPreferences()``来获取它的引用。名字中的"Shared"可能会让人疑惑，它是指允许在当前程序的各部分间共享，而不能与其它程序共享。
+ 选项信息可以随时为用户修改，因此我们需要提供一个机制来跟踪选项信息的变化。为此我们在StatusActivity中提供一个``OnSharedPreferenceChangeListener``接口的实现，并注册到SharedPreferences对象中。具体内容将在后面讨论。


% Now that we have username, password and API root coming from user-defined preferences, we can refactor our twitter code so it no longer hard-codes them. To do that, we add a private method to StatusActivity that is responsible for returning valid twitter object. This method lazily initializes twitter meaning if twitter exists it returns it as-is, otherwise creates it.

现在用户名、密码与API root几项都已定义。接下来我们可以重构代码中的Twitter对象部分，消除原先的硬编码。我们可以为StatusActivity添加一个私有方法，用以返回可用的twitter对象。它判断twitter对象是否存在，若不存在，则创建新对象。

{CODE}
private Twitter getTwitter() {
        if (twitter == null) {  // #{1}
                String username, password, apiRoot;
                username = prefs.getString("username", "");     // #{2}
                password = prefs.getString("password", "");
    apiRoot = prefs.getString("apiRoot", "http://yamba.marakana.com/api");

                // Connect to twitter.com
                twitter = new Twitter(username, password);      // #{4}
                twitter.setAPIRootUrl(apiRoot); // #{5}
        }
        return twitter;
}
{/CODE}

% + Only if twitter is null, i.e. undefined, we create it.
% + Get the username and password from the shared preference object. The first parameter in getString() is the key we assigned to each preference item, such as username and password. The second argument is the default value in case such preference is not found. Keep in mind that first time user runs your application, the preference file doesn’t exist so defaults will be used. So, if user hasn’t went to PrefsActivity to setup her preferences, this code will attempt to login with empty username and password, and thus fail. The failure however is going to happen when try try to do the actual status update because that’s how jtwitter library is designed.
% + We login to twitter service with user-defined preferences.
% + Remember that we need to update the actual service that we using by updating the API root URL for that service.

+ 仅在twitter为null时创建新对象。
+ 从SharedPreferences对象中获取username与password。``getString()``的第一个参数是选项条目的键，比如"username"和"password"，第二个参数是条目不存在时备用的默认值。因此，如果用户在登录前还没有设置个人选项，到这里用户名密码就都是空的，自然也就无法登录。但是由于jtwitter设计的原因，用户只有在尝试发送消息时才会看到错误。
+ 按照用户提供的用户名密码登录。
+ 我们需要提供自己的API root才可以访问twitter服务。

% Now, we don’t use twitter object directly any more, but call getTwitter() to get it instead. So, onClick() becomes like this:

到这里，我们不再直接引用twitter对象，而统一改为通过``getTwitter()``获取它的引用。修改后的``onClick()``方法如下：

{CODE}
public void onClick(View v) {

        // Update twitter status
        try {
                getTwitter().setStatus(editText.getText().toString());
        } catch (TwitterException e) {
                Log.d(TAG, "Twitter setStatus failed: " + e);
        }
}
{/CODE}

% Note that although we moved the code where we initialize our connection to the cloud, we still need the AsyncTask to deal with the fact that this call is still blocking and may take a while to complete, as it’s subject to network availability and latency.

留意，我们虽将初始化的代码移到了外面，但它依然是阻塞的，可能会因为网络状况的不同产生一定的延迟。日后我们仍需对此做些考虑，利用AsyncTask来改进它。

% Now, as we mentioned before when updating onCreate() and registering for preference updates, we need to handle what happens when user changes username or password. By registering prefs.registerOnSharedPreferenceChangeListener(this) in onCreate() and implementing OnSharedPreferenceChangeListener, we got a callback method onSharedPreferenceChanged() that system will invoke whenever preferences change. In this method, we simply invalidate the twitter object so next time it is needed, getTwitter() will recreate it.

前面修改``onCreate()``时曾提到，我们需要跟踪用户名与密码的变化。因此，在当前的类中添加``onSharedPreferenceChanged()``方法，然后在``onCreate()``中通过``pres.registerOnSharedPreferenceChangeListener(this)``将它注册到prefs对象，这样就得到一个回调函数，它会在选项信息变化时触发。在这里我们只需简单将twitter设为null，到下次获取引用时，``getTwitter()``会重新创建它的实例。

{CODE}
public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
        // invalidate twitter object
        twitter = null;
}
{/CODE}



% ==File System, Explained==
==简介文件系统==

% So, where are these preferences stored on the device? How secure is my username and password? To answer that, we need to look at how Android filesystem is organized.

话说回来，前面的这些选项信息又是储存在设备的哪里？我的用户名与密码是否安全？在这些问题之前，我们需要先对Android的文件系统有所了解。

% ===Exploring File System===
===浏览文件系统===

% There are two ways for you to access the file system on an Android device. One way is using Eclipse, the other command line.

访问Android的文件系统有两种方式。一种是通过Eclipse，另一种是通过命令行。

% In Eclipse, we use File Explorer view to access the file system. To open up the File Explorer view, go to Window→Show View→Other…→Android→File Explorer. You can also access File Explorer view via DDMS Perspective. Select DDMS Perspective in the top-right corner of your Eclipse [images/07-icon_ddms.png] or go to Window→Open Perspective→Other…→DDMS. If you have multiple devices connected to your workstation, make sure you select which one you are working with in the Devices view. You should now be able to navigate through the file system of the device.

Eclipse中提供了一个File Explorer工具供我们访问文件系统。要打开它，可以选择``Window→Show View→Other…→Android→File Explorer``，也可以单击右上角的DDMS 中访问它。要打开DDMS，可以单击右上角的DDMS Perspective[images/07-icon_ddms.png]，也可以选择``Window→Open Perspective→Other…→DDMS``。如果在工作台上连接着多台设备，选择出正确的设备，然后就可以访问它的文件系统了。

% If you prefer the command line, you can always use adb shell to get to the shell of the device. From there you can explore the file system like you would on any other Unix platform.

如果更喜欢命令行，adb shell就是你的首选。通过它，你可以像访问Unix系统那样访问设备的文件系统。

% ===File System Partitions===
===文件系统的分区===

% There are three main parts of the file system on every Android device. [增加 As shown in Figure 7.5, “The filesystem as seen via File Explorer in Eclipse”,] They are:

Android设备主要有三个分区，即：

% - System partition at /system/
% - SDCard at /sdcard/
% - User Data partition at /data/

- 系统分区：/system/
- SDCard分区：/sdcard/
- 用户数据分区：/data/

**图 7.5. 通过Eclipse的File Explorer查看文件系统**

[images/07-FileSystem.png]


% ===System Partition===
===系统分区===

% System partition is where your entire Android operating system is. This is the main partition containing all your preinstalled applications, system libraries, Android framework, linux command line tools, and so on.

系统分区用于存放整个Android操作系统。预装的应用程序、系统库、Android框架、Linux命令行工具等等，都存放在这里。

% System partition is mounted read-only, meaning you as developer have very little influence over it. As such, this partition is of limited interest to us.

系统分区是以只读模式挂载的，应用开发者针对它的发挥空间不大，因此我们不多做关注。

% The system partition in the Emulator corresponds to system.img file in your platform images directory, located in android-sdk/platforms/android-8/images/ folder.

在仿真器中，系统分区对应的映像文件是``system.img``，它与平台相关，位于android-sdk/platforms/android-8/images目录。

% ===SDCard Partition===
===SDCard分区===

% SDCard partition is a free-for-all mass storage. Your app can read files from this partition as well as write files to it if it holds WRITE_TO_EXTERNAL_STORAGE permission. This is a great place to store large files, such as music, photos, videos and similar.

SDCard分区是个通用的存储空间。你的程序只要拥有WRITE_TO_EXTERNAL_STORAGE权限，即可随意读写这个文件系统。这里最适合存放音乐、照片、视频等大文件。

% Note that since FroYo version of Android, /sdcard mount point appears in Eclipse File Explorer under /mnt/sdcard location. This is because of the new feature in FroYo to allow for storing and running applications on the SDCard as well.

留意，Android自FroYo版本开始，Eclipse File中显示的挂载点从/sdcard改为了/mnt/sdcard。这是因为FroYo引入的新特性，允许在SDCard中存储并执行程序。

% As an app developer, SDCard partition is very useful and important to you. At the same time, this partition is not very structured.

对应用开发者而言，SDCard分区无疑十分有用。不过它的文件结构也相对松散一些，管理时需要注意。

% This partition typically corresponds to sdcard.img in your Android Virtual Device (AVD) directory. This directory is in you ~/.android/avd/ folder and will have a subdirectory for each specific virtual device. On the physical device, it is an actual SD card.

这个分区的镜像文件一般是sdcard.img，位于对应设备的AVD目录之下，也就是``~/.android/avd``之下的某个子目录。对真机而言，它就是一个SD卡。

% ===User Data Partition===
===用户数据分区===

% As user and app developer, the most important partition is the User Data partition. This is where all your user data is stored, all the downloaded apps are located, and most importantly, all apps' data is. This includes both preinstalled apps as well as user-downloaded apps.

对开发者和用户来讲，用户数据分区才是最重要的。用户数据都储存在这里，下载的应用程序储存在这里，而且所有的应用程序数据也都储存在这里。

% So, while user apps are stored in /data/app/ folder, the most important folder to us as app developer is /data/data/ folder. More specifically, within this folder there’s a subfolder corresponding to each app. This folder is identified by the Java package that this app used to sign itself. Again, this is why Java packages are important to Android security.

用户安装的应用程序都储存在/data/app目录，而开发者关心的数据文件都储存在/data/data目录。在这个目录之下，每个应用程序对应一个单独的子目录，按照Java package的名字作为标识。从这里可以再次看出Java package在Android安全机制中的地位。

% Android framework provides number of handy methods as part of context that help you access user data file system from within your application. Take a look at getFilesDir() for example.

Android框架提供了许多相关的辅助函数，允许应用程序访问文件系统，比如``getFilesDir()``。

% This partition typically corresponds to user-data.img in your Android Virtual Device (AVD) directory. As before, this directory is in your ~/.android/avd/ folder and will have a subdirectory for each specific virtual device.

这个分区的镜像文件是user-data.img，位于对应设备的AVD目录之下。同前面一样，也是在~/.android/avd/之下的某个子目录。

% When you create a new app, you assign your Java code to a specific package. Typically, this package follows the Java convention of reverse domain name plus app name. For example, Yamba app is in com.marakana.yamba package. So, once installed, Android creates a special folder just for this app under /data/data/com.marakana.yamba/. This folder is the cornerstone of our private secured file system dedicated to each app.

新建应用程序的时候，你需要为Java代码指定一个package，按约定，它的名字一般都是逆序的域名，比如``com.marakana.yamba``。应用安装之后，Android会为应用单独创建一个目录``/data/data/com.marakana.yamba/``。其中的内容就是应用程序的私有数据。

%TALK: 查了下，这些数据还不是加密的，似乎把SD卡偷走就能读出来里面的数据...没搞懂这安全是什么来头。 -fleuria

% There will be sub-folders in /data/data/com.marakana.yamba2/, but they are well-defined. For example, the preferences are in /data/data/com.marakana.yamba2/shared_prefs/. As a matter of fact, if you open up DDMS perspective in your Eclipse and select File Explorer, you can navigate to this partition. You will probably see com.marakana.yamba2_preferences.xml file in there. You could pull this file and exam in it, or you could use adb shell.

``/data/data/com.marakana.yamba2/``下面也有子目录，但是结构很清晰，不同的数据分在不同的目录之下，比如首选项信息就都位于``/data/data/com.marakana.yamba2/shared_prefs/``。通过Eclipse的File Explorer访问这一目录，可以在里面看到一个``com.marakana.yamba2_preferences.xml``文件。你可以把它拷贝出来，也可以在adb shell中直接查看。

% adb shell is another one of those common adb subcommands to access the shell of your device (either physical or virtual). For instance, you could just open up your command line terminal and type:

adb shell是adb的另一个重要命令，它允许你访问设备(真机或者虚拟机)的shell。就像下面这样：

{CODE}
[user:~]> adb shell
# cd /data/data/com.marakana.yamba2/shared_prefs
# cat com.marakana.yamba2_preferences.xml
<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<map>
<string name="password">password</string>
<string name="apiRoot">http://yamba.marakana.com/api</string>
<string name="username">student</string>
</map>
#
{/CODE}

% This XML file represents the storage for all our preference data for this application. As you can see, our username, password and API root are all stored in there.

这个XML文件里表示的就是这个程序中的选项数据。可见，用户名、密码与API root都在这里。

%TALK: 感觉这里很坑爹。 -fleuria

% ===File System Security===
===文件系统的安全机制===

% So, how secure is this? This is a common question by security folks. Username and password stored in clear text always raises eyebrows.

对安全问题敏感的同学肯定要问了，这样安全吗？明文存储的用户名密码总是容易让人神经紧张。

% To answer this question, I usually compare it to finding someone’s laptop on the street. While indeed we can easily gain access to the "hard-drive" via adb tool, that doesn’t mean we have a way of reading its data. Each folder under /data/data/ is going to belong to a separate user account. This user account is managed by Linux. Unless our app is that app, it won’t have access to that folder. So, short of us reading byte-by-byte on the physical device, even clear-text data is secure.

其实这个问题就像是在大街上捡到一台笔记本，我们可以拆开它的硬盘，但不一定能读取它的数据。``/data/data``之下的每个子目录都有单独的用户帐号，由Linux负责管理。也就是说，只有我们自己的应用程序才拥有访问这一目录的权限。数据既然无法读取，明文也就是安全的。

%TALK: 坑爹！！！ -fleuria

% On the Emulator, we have root permissions meaning we can explore entire file system. This is useful for development purposes.

在仿真器上，我们只要拥有root权限即可访问整个文件系统。这有助于方便开发者进行调试。

(译者注：作者在此说法似乎有矛盾之处。如果手机被偷走，依然不能排除小偷使用root权限窃取其中密码的可能。译者的建议是尽量避免使用明文。谈及安全问题，神经紧张一些总不会错。)


% ==Summary==
==总结==

% At this point, the user can specify the username and password for the micro-blogging site. This makes the app usable to way more people than the the version that had this information previously hard-coded.

到这里，用户可以设置自己的用户名与密码。同时移除原先的硬编码，使得程序更加可用。

% Figure 7.6, “Yamba Completion” illustrates what we have done so far as part of the design outlined in Figure 5.4, “Yamba Design Diagram”:

//图7.6// 展示了目前我们已完成的部分。完整图参见 //图5.4//。

**图 7.6. Yamba完成图**

[images/07-Yamba-2.png]


