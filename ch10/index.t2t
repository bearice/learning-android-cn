%
%
%
% ==Lists and Adapters==

=List与Adapter=

% In this chapter, you will learn how to create selection widgets, such as a ListView. But this isn’t just a chapter about user interface elements. We are continuing to deepen our understanding of data from the previous chapter by learning how to read data from the database of statuses and simply output it on the screen as scrollable text first. You will then learn about Adapters in order to connect your database directly with the list. You will create a custom adapter in order to be able to implement some additional functionality. You will link this new activity with your main activity so that the user can both post and read tweets.

在本章，你将学到选择性控件(比如``ListView``)的创建方法。但是这里讨论的重点绝对不在用户界面，而在于进一步巩固我们在上一章中对“数据”的理解，前面是简单地读取数据再输出到屏幕，到这里改为使用Adapter直接将数据库与List绑定在一起。你可以创建一个自己的Adapter，从而添加额外的功能。在这里我们新建一个界面，并将其作为用户发送/阅读消息的主界面。

% By the end of this chapter, your app will be able to post new tweets, as well as pull them from Twitter, store them in local database, and let the user read the statuses in a nice and efficient UI. At that point, your app will have three activities and a service.

在前面我们已经实现了发送消息、从Twitter读取消息、缓存在本地数据库等功能，在本章结束，它将拥有一个美观高效的UI允许用户阅读消息。到这里，你的程序将拥有三个Activity和一个Service。


==TimelineActivity==

% We’re going to create a new activity called TimelineActivity to display all the statuses from our friends. It pulls the data from the database and displays it on the screen. Initially, we do not have a lot of data in the database, but as we keep on using the application, the amount of statuses we have may explode. Our application needs to account for that.

接下来我们新建一个Activity，即``TimelineActivity``，用以显示朋友的消息。它从数据库中读取消息，并显示在屏幕上。在一开始我们的数据库并不大，但是随着应用使用时间的增长，其中的数据量就不可遏制了。我们必须针对这个问题做些考虑。

% We are going to build this activity in couple of steps, at each point keeping the application whole and complete as we make improvements.

我们将创建这一Activity分成两步。保证经过每一轮迭代，应用都是完整可用的。

% + The first iteration of TimelineActivity uses a TextView to display all the output from the database. Since there may be quite a bit of data, we will use ScrollView to wrap our large amount of text in so that there are scroll bars on provided.
% + The second iteration uses the much more scalable and efficient ListView and Adapter approach. In this step, you will learn how Adapters and Lists work.
% + Finally, we will create a custom Adapter to handle some additional business logic. At this point, we are going under the hood of an adapter and adding custom processing. You’ll understand the purpose and usage of adapters better after this exercise.

+ 第一次迭代：使用一个TextView显示数据库中的所有数据，由于数据量可能会比较大，我们将它置于ScrollView中，加一个滚动条。
+ 第二次迭代：改用ListView与Adapter，这样伸缩性更好，效率也更高。你将在这里了解到Adapter与List的工作方式。
+ 最后创建一个自定义的Adapter，在里面添加些额外的业务逻辑。这需要深入Adapter的内部，你可以体会它的设计动机与应用方式。


% ==Basic TimelineActivity Layout==
==TimelineActivity的基本布局==

% In this first iteration, we are creating a new layout for the TimelineActivity. This layout initially uses a TextView to display all the data that we have in the database. This is fine initially when we don’t have too many statuses to show.

在第一次迭代中，我们为TimelineActty创建一个新的布局(Layout)，它使用一个TextView来展示数据库中的所有消息。在刚开始的时候数据量不大，这样还是没有问题的。

% ===Introducing ScrollView===
===简介ScrollView===

% Since it’s unlikely that all our data will fit on a single page, we need a way to scroll the text. To do that, we use ‘ScrollView`. ScrollView is like a window that displays part of a larger component that takes more space than the screen provides. It does that by providing convenient scroll bars as as needed. To make some potentially large views scrollable, you wrap them with this ScrollView. For example, we have a printout of many friends’ statuses in form of a TextView. This TextView could become large as there are many statuses. In order to make it scrollable on a small screen, we put it into a ScrollView.

不过数据一多，我们就不能保证所有的消息正好排满一页了，这时应使用``'ScrollView'``使之可以滚动。ScrollView与Window相似，不过它可以在必要时提供一个滚动条，从而允许在里面存放超过一屏的内容。对付可能会变大的View，用ScrollView把它包起来就行。比如这里我们靠TextView输出所有朋友的消息，消息一多，它也跟着变大。在较小的屏幕中显示不开，就把它放在ScrollView里使之可以滚动。

% A ScrollView can only contain one direct child. If you want to combine multiple views into a single view that scrolls, you need to first organize those views into another layout, like you did previously in the section called “StatusActivity Layout”, and than add that layout into ScrollView.

ScrollView中只能存放单独的一个子元素。要让多个View一起滚动，就需要像前面``StatusActivity Layout``一节所做的那样，先把它们放在另一个Layout里，随后把整个Layout添加到ScrollView里。

% Typically you will want ScrollView to take all the available space on the screen. Usually, therefore you will specify its layout width and height as fill_parent.

通常你会希望ScrollView能够填满屏幕的所有可用空间。把它的高度与宽度都设置为``fill_parent``即可。

% A ScrollView is usually not manipulated from Java, so it doesn’t require an id.

ScrollView通常不需要使用Java代码控制其行为，因此无需id。

% In this example, we wrap our TextView with a ScrollView so that if there’s a lot of text to display, ScrollView automatically adds scroll bars.

在这个例子中，我们使用ScrollView把TextView包了起来。以后TextView中的内容变多体积变大，ScrollView就会自动为它加上滚动条。

**Example 10.1. res/layout/timeline_basic.xml**
{CODE}
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:orientation="vertical" android:layout_height="fill_parent"
  android:layout_width="fill_parent" android:background="@drawable/background">

  <!-- Title #{1} -->
  <TextView android:layout_width="wrap_content"
    android:layout_height="wrap_content" android:layout_gravity="center"
    android:layout_margin="10dp" android:text="@string/titleTimeline"
    android:textColor="#fff" android:textSize="30sp" />

  <!-- Text output wrapper #{2} -->
  <ScrollView android:layout_height="fill_parent"
    android:layout_width="fill_parent">

    <!-- Text output #{3} -->
    <TextView android:layout_height="fill_parent"
      android:layout_width="fill_parent" android:id="@+id/textTimeline"
      android:background="#6000" />
  </ScrollView>

</LinearLayout>
{/CODE}

% + This is the title that we show at the top of this Activity’s screen. Notice that we defined titleTimeline string resource in /res/values/strings.xml file, just like we did before in the section called “Strings Resource”.
% + ScrollView that is wrapping our TextView and adding scroll bars as needed.
% + TextView that shows the actual text, in this case statuses of our friends coming from the database.

+ 在Activity屏幕顶部显示的标题。留意字符串``titleTimeline``的定义在``/res/values/strings.xml``文件中，具体参见``String Resource``一节。
+ ScrollView包含TextView，在需要时添加滚动条。
+ TextView用以显示文本，在这里就是从数据库中读取的用户消息。


% ===Creating TimelineActivity Class===
===创建TimelineActivity类===

% Now that we have the layout file, we need to create the TimelineActivity class. To do that, just as with any other Java file, in Eclipse Package Explorer, right-click on your com.marakana.yamba package, choose New→Class and for Name enter TimelineActivity.

我们已经有了一个布局文件，接下来创建TimelineActivity类。同其它文件一样，进入Eclipse Package Explorer，右击com.marakana.yamba包，选择``New→Class``，在名字一栏输入//TimelineActivity//。

% And just as before, whenever we create a new Java class that is one of those main building blocks—such as Activities, Services, Broadcast Receivers, and Content Providers—we first subclass a base class provided by the Android framework. In case of Activities, that class is Activity.

就像前面一样，我们创建的类只要是基本构件——不管Activity，Service，Broadcast Reciever还是Content Provider——就肯定是基于Android框架提供的基类派生出来的子类。对Activity而言，其基类即``Activity``。

% The method we almost universally override in any activity is onCreate(). This is a great place for us to initialize the database. The flip side of the coin is onDestroy(), a good place to clean up anything that we create in onCreate(). In this case, we close the database in onDestroy(). Since we’d like to have the data as fresh as possible, we put the code for querying the database and outputting the data in onResume(), the method called every time this activity is brought up front. Here’s what our code looks like:

我们通常会为每个Activity都重载一个``onCreate()``，这是初始化数据库的好地方。与之对应，我们在``onDestroy()``中清理``onCreate()``中创建的资源，也就是关闭数据库。我们希望显示的消息尽可能最新，因此把查询数据库的代码放在``onResume()``中，这样在界面每次显示时都会执行。代码如下：

{CODE}
package com.marakana.yamba5;

import android.app.Activity;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.Bundle;
import android.widget.TextView;

public class TimelineActivity1 extends Activity { // #{1}
  DbHelper dbHelper;
  SQLiteDatabase db;
  Cursor cursor;
  TextView textTimeline;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.timeline);

    // Find your views
    textTimeline = (TextView) findViewById(R.id.textTimeline);

    // Connect to database
    dbHelper = new DbHelper(this);  // #{2}
    db = dbHelper.getReadableDatabase();  // #{3} 
  }

  @Override
  public void onDestroy() {
    super.onDestroy();

    // Close the database
    db.close(); // #{4}
  }

  @Override
  protected void onResume() {
    super.onResume();

    // Get the data from the database
    cursor = db.query(DbHelper.TABLE, null, null, null, null, null,
        DbHelper.C_CREATED_AT + " DESC"); // #{5}
    startManagingCursor(cursor);  // #{6}

    // Iterate over all the data and print it out
    String user, text, output;
    while (cursor.moveToNext()) {  // #{7}
      user = cursor.getString(cursor.getColumnIndex(DbHelper.C_USER));  // #{8}
      text = cursor.getString(cursor.getColumnIndex(DbHelper.C_TEXT));
      output = String.format("%s: %s\n", user, text); // #{9}
      textTimeline.append(output); // #{10}
    }
  }
}
{/CODE}

% + This is an Activity, so we start by subclassing Android framework Activity class.
% + We need access to the database in order to get the timeline data. onCreate() is a good place to connect to the database.
% + Once dbHelper opens the database file, we need to ask it for the actual database object. To do that, we can use either getReadableDatabase() or getWritableDatabase(). In this case, we are only reading the data from the timeline, so we open the database for reading only.
% + At some point we need to close the database and release that resource. If database was opened in onCreate(), the counterpart to that would be onDestroy(). So, we close the database there. Remember that onDestroy() is not called unless the system has to free up resources.
% + To query the data from the database, we use the query() method. While this method seems to contain almost endless parameters, most of them map nicely to various parts of SQL SELECT statement. So this line is equivalent to SQL SELECT * FROM timeline ORDER BY created_at DESC. The various null values refer to parts of SELECT statement we are not using, such as WHERE, GROUPING, and HAVING. The data returned to us is of type Cursor which is an iterator.
% + startManagingCursor() is a convenience method that tells the activity to start managing cursor’s lifecycle the same way it manages its own. What that means is that when this activity is about to be destroyed, it will make sure to release any data referred to by the cursor, thus helping Java’s garbage collector clean up memory faster. The alternative is for us to manually add code in various override methods and worry about cursor management ourselves.
% + cursor, if you recall from the section called “Cursors” represents all the data we got back from the database SELECT statement that was effectively executed by our query() method. This data is generally in form of a table, with many rows and columns. Each row represents a single record, such as a single status in our timeline. Each row also has columns that we predefined, such as _id, created_at, user, and txt. As we mentioned before, cursor is an iterator meaning we can step through all its data one record at a time. First call to Cursor’s moveToNext() positions the cursor at the start. moveToNext() stops when there’s no more data to process.
% + For each record that the cursor currently points to, we can ask for its value by type and column index. So cursor.getString(3) returns a String value of the status, and cursor.getLong(1) gives us the timestamp when this record was created. Refer back to Chapter 9, Database to see how we define strings such as C_USER and C_TEXT in our program that map to column names in the database. However, having hardcoded column indices is not a good practice because if we ever change the schema, we’ll have to remember to update this code. Also, the code is not very readable in this form. A better practice is to ask the database for the index of each column. We do that with the cursor.getColumnIndex() call.
% + We use String.format() to format each line of the output. In this example, as we chose TextView for our widget to display the data, we can only display text, in other words, formatted strings. In the later iteration of this code, we’ll improve on this.
% + We finally append that new line of output to our text view textTimeline so user gets to see it on the screen.

+ 这是个Activity，因此它继承自Android框架提供的``Activity``类。
+ 我们需要访问数据库以得到Timeline的相关数据，而``onCreate()``正是连接数据库的好地方。
+ 通过dbHelper打开数据库文件之后，我们需要它的``getReadableDatabase()``或``getWritableDatabase()``才可以得到实际的数据库对象。在这里我们只需读取Timeline的相关数据，因此按只读方式打开数据库。
+ 我们得记着关闭数据库并释放资源。数据库是在``onCreate()``中打开，因此可以在``onDestroy()``中关闭。注意``onDestroy()``只有在系统清理资源时才被调用。
+ 调用``query()``方法从数据库中查询数据，返回一个Cursor对象作为迭代器。参数似乎多的过了头，不过几乎都是对应着SQL的SELECT语句的各个部分。在这里也就相当与``SELECT * FROM timeline ORDER BY created_at DESC``。这些``null``表示我们并没有使用SQL语句中相应的部分，比如``WHERE``, ``GROUPING``, 与 ``HAVING``等。
+ ``startManagingCursor()``用于提示Activity自动管理Cursor的生命周期，使之同自己保持一致。“保持一致”的意思是，它能保证在Activity销毁时，同时释放掉Cursor关联的数据，这样有助于优化垃圾收集的性能。没有自动管理的话，就只能在各个重载函数中添加代码手工地管理Cursor了。
+ cursor——回忆下``Cursors``一节的内容——即通过``query()``方法查询数据库所得的结果。按照表的形式，暂存多行多列的数据。每一行都是一条独立的记录——比如Timeline中的一条消息——而其中的列则都是预先定义的，比如``_id``, ``created_at``, ``user``以及``txt``。前面提到Cursor是个迭代器，我们可以通过它在每次迭代中读取一条记录，而在没有剩余数据时退出迭代。
+ 对于cursor的当前记录，我们可以通过类型与列号来获取其中的值。由此，cursor.getString(3)返回一个字符串，表示消息的内容；cursor.getLong(1)返回一个数值，表示消息创建时的时间戳。但是，把列号硬编码在代码中不是个好习惯，因为数据库的原型一旦有变化，我们就不得不手工调整相关的代码，而且可读性也不好。更好的方法是，使用列名——回想下，在第九章[数据库 #ch9]我们曾定义过C_USER与C_TEXT等字符串——调用``cursor.getColumnIndex()``得到列号，然后再取其中的值。
+ 使用``String.t()``对每行输出进行格式化。在这里我们选择使用TextView控件显示数据，因此只能显示文本，或者说有格式的文本。我们在以后的迭代中更新这里。
+ 最后把新的一行追加到textTimeline的文本中，用户就可以看到了。


% While this approach works for smaller data sets, it is not optimal or recommended. The better approach is to use a ListView to represent the list of statuses that we have in the database. ListView, which we’ll use in the next version of our TimelineActivity, is much more scalable and efficient.

上面的方法对较小的数据集还没问题，但绝对不是值得推荐的好方法。更好的方法是使用ListView，正如下文所示——它可以绑定数据库，伸缩性更好的同时也更加高效。


% ==About Adapters==
==关于Adapter==

% A ScrollView will work for a few dozen records. But what if your status database has hundreds or even thousands of records? Waiting to get and print them all would be highly inefficient. The user probably doesn’t even care about all of the data anyhow.

一个ScrollView足以应付几十条记录，但是数据库里要有上百上千条记录时怎么办？全部读取并输出当然是很低效的。更何况，用户不一定关心所有的数据。

% To address this issue, Android provides adapters. These are a smart way to connect a View with some kind of data source (see Figure 10.1, “Adapter”). Typically, your view would be a ListView and the data would come in form of a Cursor or Array. So adapters come as subclasses of CursorAdapter or ArrayAdapter.

针对这一问题，Android提供了Adapter，从而允许开发者为一个View绑定一个数据源(如图10.1, //"Adapter"//)。典型的情景是，View即ListView，数据即Cursor或者数组(Array)，Adapter也就与之对应：CursorAdapter或者ArrayAdapter。

	**Figure 10.1. Adapter**
		[images/10-Adapter.png]


% ===Adding ListView to TimelineActivity===
===为TimelineActivity添加ListView===

% As before, our first stop in upgrading out applications is our resources file. We’ll add a ListView to the timeline layout by editing timeline.xml.

同前面一样，第一步仍是修改资源文件。修改``timeline.xml``，为Timeline的布局添加一个ListView。

**Example 10.3. res/layout/timeline.xml**

{CODE}
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:orientation="vertical" android:layout_height="fill_parent"
  android:layout_width="fill_parent" android:background="@drawable/background">
  <TextView android:layout_width="wrap_content"
    android:layout_height="wrap_content" android:layout_gravity="center"
    android:layout_margin="10dp" android:text="@string/titleTimeline"
    android:textColor="#fff" android:textSize="30sp" />

  <!-- #{1}  -->
  <ListView android:layout_height="fill_parent"
    android:layout_width="fill_parent" android:id="@+id/listTimeline"
    android:background="#6000" />

</LinearLayout>
{/CODE}

% + Adding ListView to your layout is like adding any other widget. The main attributes are id, and layout_height, and layout_width.

+ 添加ListView与添加其它控件(widget)是一样的。主要的属性: ``id``，``layout_height``以及``layout_width``。


% ===ListView versus ListActivity===
===ListView vs. ListActivity===

% We could have also used ListActivity as the parent class for our TimelineActivity. ListActivity is an activity that has a ListView. Either approach would work, but we choose to subclass Activity and create ListView separately to provide step-by-step, incremental learning.

ListActivity即含有一个ListView的Activty，我们完全拿它作为TimelineActivity的基类。在这里我们选择独立实现自己的Activity，再给它加上ListView，是出于学习的考虑。

% ListActivity is slightly easier to use in cases where there the builtin ListView is the only widget in the activity. ListActivity also makes it really easy to assign an existing array of elements to its list via the XML binding. However, since we are using a Cursor for data and not an array (because our data comes from the database), and since we do have an additional TextView for the scrollview’s title, the simplicity of ListActivity in this case is outweighed by customization we require.

如果Activity中只有一个ListView，使用ListActivity可以稍稍简化下代码。有XML绑定，为ListActivity添加元素也轻而易举。不过在这里我们使用的数据源是Cursor而非数组(因为我们的数据来自数据库)，而且在前面我们也添加过一个TextView作为ScrollView的标题，已经有了一定程度的自定义，换用ListActivity不合适。

%TALK: "ListActivity also makes it really easy to assign an existing array of elements to its list via the XML binding."有疑问，为它绑定一个数组，为什么是"via the XML binding"?


% ===Creating a Row Layout===
===为Row创建一个Layout===

% There’s one more XML file to take care of. While timeline.xml describes the entire activity, we also need to specify what a single row of data looks like—tht is, a single line item on the screen that will show information such as who said what and when.

还有一个XML文件需要考虑。有``timeline.xml``描述整个Activity的布局，我们也需要描述单行数据的显示方式——也就是在屏幕上显示的单条消息，谁在什么时间说了什么。

% The easiest way to do that is to create another XML file just for that row. To do that, as for any new XML file, we use the Android New XML File dialog window: File→New→Android New XML File. Let’s name this file row.xml and select Layout for the type.

最简单的方法就是给这些行单独创建一个XML文件。同前面新建的XML文件一样，选择File→New→Android New XML File打开Android New XML File对话框，命名为row.xml，type一项选择Layout。

% For this layout, we chose one LinearLayout going vertically and having two lines. The first line consists of the user and timestamp, and the second contains the actual status message. Notice that the first line uses another LinearLayout to position the user and timestamp horizontally next to each other.

我们在这里选择LinearLayout，让它垂直布局，分两行。第一行包含用户名与时间戳，第二行包含消息的内容。留意第一行中用户名与时间戳的位置是水平分布的。

% The row of data in the ListView is represented by a custom layout defined in row.xml file.

ListView中单行的布局在文件``row.xml``中定义。


% ===Creating an Adapter in TimelineActivity.java===
===在TimelineActivity.java中创建一个Adapter===

% Now that we have the XML files sorted out, we are ready to update the Java code. First we need to create the adapter. Adapters generally come in two flavors: those that represent array data and those that represent cursor data. Since our data is coming from the database, we are going to use the cursor-based adapter. One of the simplest of those is SimpleCursorAdapter.

现在我们已经有了相应的XML文件，接下来修改Java代码，把Adapter创建出来。Adapter通常有两种形式：表示来自数组的数据，或者表示来自Cursor的数据。在这里我们的数据来自数据库，因此选择基于Cursor的Adapter。其中最简单的当数``SimpleCursorAdapter``。

% SimpleCursorAdapter requires us to describe a single row of data (which we do in row.xml), the data (a cursor in our case) and the mapping for a single record of data to the single row in the list. The last parameter maps each cursor column to a view in the list.

``SimpleCursorAdapter``需要我们给出单行数据显示方式的描述（在row.xml中已经做好了），数据（在这里是一个Cursor），以及单个record到List中单行的映射方法。最后的这个参数将Cursor的每列映射为List中的一个View。

**Example 10.5. TimelineActivity.java, version 2**
{CODE}
package com.marakana.yamba5;

import android.app.Activity;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.Bundle;
import android.widget.ListView;
import android.widget.SimpleCursorAdapter;

public class TimelineActivity2 extends Activity {
  DbHelper dbHelper;
  SQLiteDatabase db;
  Cursor cursor;  // #{1}
  ListView listTimeline;  // #{2}
  SimpleCursorAdapter adapter;  // #{3}
  static final String[] FROM = { DbHelper.C_CREATED_AT, DbHelper.C_USER,
      DbHelper.C_TEXT };  // #{4}
  static final int[] TO = { R.id.textCreatedAt, R.id.textUser, R.id.textText }; // #{5}

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.timeline);

    // Find your views
    listTimeline = (ListView) findViewById(R.id.listTimeline);  // #{6}

    // Connect to database
    dbHelper = new DbHelper(this);
    db = dbHelper.getReadableDatabase();
  }

  @Override
  public void onDestroy() {
    super.onDestroy();

    // Close the database
    db.close();
  }

  @Override
  protected void onResume() {
    super.onResume();

    // Get the data from the database
    cursor = db.query(DbHelper.TABLE, null, null, null, null, null,
        DbHelper.C_CREATED_AT + " DESC");
    startManagingCursor(cursor);

    // Setup the adapter
    adapter = new SimpleCursorAdapter(this, R.layout.row, cursor, FROM, TO);  // #{7}
    listTimeline.setAdapter(adapter); // #{8}
  }

}
{/CODE}

% + Cursor to all the status updates that we have in the database.
% + listTimeline is our ListView that displays the data.
% + adapter is our custom adapter, explained in the text that follows this example.
% + FROM is a String array specifying which columns in the cursor we’re binding from. We use the same strings that we’ve already used to refer to columns in our program
% + TO is an array of integers representing IDs of Views in the row.xml layout that we are binding data to. The number of elements in FROM and TO must be the same, so that element at index 0 in FROM maps to element 0 in TO, and so on.
% + We get the ListView from the XML layout.
% + Once we have the data as a cursor, the layout of a single row from the row.xml file, and the FROM and TO constants for mapping the data, we are ready to create the SimpleCursorAdapter.
% + Finally, we need to tell our ListView to use this adapter.

+ 这个Cursor用以读取数据库中的朋友消息。
+ ``listTimeLine``即我们用以显示数据的ListView。
+ ``adapter``是我们自定义的Adapter，这在后文中讲解。
+ ``FROM``是个字符串数组，用以指明我们需要的数据列。其内容与我们前面引用数据列时使用的字符串相同。
+ ``TO``是个整型数组，对应布局row.xml中指明的View的ID，用以指明数据的绑定对象。FROM与TO的各个元素必须一一对应，比如``FROM[0]``对应``TO[0]``，``FROM[1]``对应``TO[1]``，如是继续。
+ 获取XML布局中声明的ListView。
+ 获得了Cursor形式的数据，``row.xml``定义了单行消息的布局，常量FROM与TO表示了映射关系，现在可以创建一个``SimpleCursorAdapter``。
+ 最后通知ListView使用这个Adapter。


==TimelineAdapter==

% TimelineAdapter is our custom adapter. Although SimpleCursorAdapter did a straightforward mapping of data in the database to views on the screen, we had an issue with the timestamp. The job of TimelineAdapter is to inject some business logic to convert Unix timestamp to relative time. We can discover that the method in SimpleCursorAdapter`that creates a displayable view from input data is `bindView(), so we’ll override that method and ask it to massage the data before it is displayed.

TimelineAdapter即我们自定义的Adapter。虽说SimpleCursorAdapter映射起数据来倒也直白，但是我们在这里有个时间戳（timestamp）需要特殊处理。TimelineAdapter的工作即与之有关：加入将Unix时间戳转换为相对时间的业务逻辑。我们可以知道，``SimpleCursorAdapter``是在``bindView()``调用中处理View的显示，因此我们将重载这个方法，在数据显示出来之前处理一下。

% Typically, if you are not sure what method to override, look at the online documentation for that particular system class that you are modifying. In this case, that’d be http://developer.android.com/reference/android/widget/SimpleCursorAdapter.html.

一般来说，若不清楚类里需要重载的函数是哪个，看下相关的官方文档即可。在这里，可以参阅http://developer.android.com/reference/android/widget/SimpleCursorAdapter.html。

**Example 10.6. TimelineAdapter.java**
{CODE}
package com.marakana.yamba5;

import android.content.Context;
import android.database.Cursor;
import android.text.format.DateUtils;
import android.view.View;
import android.widget.SimpleCursorAdapter;
import android.widget.TextView;

public class TimelineAdapter extends SimpleCursorAdapter { // #{1}
  static final String[] FROM = { DbHelper.C_CREATED_AT, DbHelper.C_USER,
      DbHelper.C_TEXT }; // #{2}
  static final int[] TO = { R.id.textCreatedAt, R.id.textUser, R.id.textText }; // #{3}

  // Constructor
  public TimelineAdapter(Context context, Cursor c) { // #{4}
    super(context, R.layout.row, c, FROM, TO);
  }

  // This is where the actual binding of a cursor to view happens
  @Override
  public void bindView(View row, Context context, Cursor cursor) { // #{5}
    super.bindView(row, context, cursor);

    // Manually bind created at timestamp to its view
    long timestamp = cursor.getLong(cursor
        .getColumnIndex(DbHelper.C_CREATED_AT)); // #{6}
    TextView textCreatedAt = (TextView) row.findViewById(R.id.textCreatedAt); // #{7}
    textCreatedAt.setText(DateUtils.getRelativeTimeSpanString(timestamp)); // #{8}
  }

}
{/CODE}

% + To create our own custom adapter, we subclass one of the Android standard adapters, in this case the same SimpleCursorAdapter we used in the previous section.
% + This constant defines the columns of interest to us in the database, as in the previous example.
% + This constant specifies the IDs of views that we’ll map those columns to.
% + Because we’re defining a new class, we need a constructor. It simply calls the parent constructor using super.
% + The only method we override is bindView(). This method is called for each row to map its data to its views, and it’s where the gist of adapter work happens. In order to reuse most of the data-to-views mapping provided by SimpleCursorAdapter, we call super.bindView() first.
% + To override default mapping for timestamp, we first get the actual timestamp value from the database.
% + Next, we find the specific TextView in the row.xml file.
% + Finally, we set the value of textCreatedAt to the relative time since the timestamp. To do this, we use Android SDK method DateUtils.getRelativeTimeSpanString().

+ 创建我们自定义的Adapter。基于Android提供的Adapter派生一个新类，这里我们选择前面用到的SimpleCursorAdapter。
+ 跟上个例子一样，这个常量用以指明数据库中我们感兴趣的列。
+ 这个常量用以指明数据列对应View的ID。
+ 因为是新定义的类，因此需要一个构造函数。在这里仅仅通过super调用父类的构造函数即可。
+ 这里只重载了一个方法，即``bindView()``。这个方法在映射每行数据到View时调用，Adapter的主要工作在这里进行了。要重用SimpleCursorAdapter原有的映射操作(数据到View)，记得先调用super.bindView()。
+ 覆盖默认针对timestamp的映射操作，需要先得到数据库中timestamp的值。
+ 然后找到对应的TextView，其定义在``row.xml``。
+ 最后，依据timestamp的值设置``textCreatedAt``的值为相对时间。通过``DateUtils.getRelativeTimeSpanString()``。


% At this point, we can further simplify our TimelineActivity class, because we moved some of the adapter details to TimelineAdapter.

前面将Adapter相关的一些细节移入了``TimelineAdapter``，因此我们可以进一步简化``TimelineActivity``类。

**Example 10.7. TimelineActivity.java, version 3**
{CODE}
package com.marakana.yamba5;

import android.app.Activity;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.Bundle;
import android.widget.ListView;

public class TimelineActivity3 extends Activity {
  DbHelper dbHelper;
  SQLiteDatabase db;
  Cursor cursor;
  ListView listTimeline;
  TimelineAdapter adapter;  // #{1}

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.timeline);

    // Find your views
    listTimeline = (ListView) findViewById(R.id.listTimeline);

    // Connect to database
    dbHelper = new DbHelper(this);
    db = dbHelper.getReadableDatabase();
  }

  @Override
  public void onDestroy() {
    super.onDestroy();

    // Close the database
    db.close();
  }

  @Override
  protected void onResume() {
    super.onResume();

    // Get the data from the database
    cursor = db.query(DbHelper.TABLE, null, null, null, null, null,
        DbHelper.C_CREATED_AT + " DESC");
    startManagingCursor(cursor);

    // Create the adapter
    adapter = new TimelineAdapter(this, cursor);  // #{2}
    listTimeline.setAdapter(adapter); // #{3}
  }

}
{/CODE}

% + We change SimpleCursorAdapter to TimelineAdapter.
% + Create a new instance of the TimelineAdapter and pass it the context and the data.
% + Set our ListView to connect to the data via the adapter.

+ 修改``SimpleCursorAdapter``为``TimelineAdapter``。
+ 新建一个``TimelineAdapter``的实例，交给它上下文及数据的引用。 
+ 将``ListView``与这个Adapter关联，从而与数据库绑定。


==ViewBinder: TimelineAdapter之外的更好选择==

% Instead of creating a new TimelineAdapter that is a subclass of SimpleCursorAdapter and overriding its bindView() method, we could also attach the business logic directly to the existing SimpleCursorAdapter. This approach is more efficient because we are not replacing what bindView() already does and we do not require a separate custom adapter class.

除去派生一个TimelineAdapter再重载``bindView()``之外，我们也可以直接为SimpleCursorAdapter添加业务逻辑。这样既能保留原先的``bindView()``所做的工作，又省了一个类，更加简便。

% To attach business logic to an existing SimpleCursorAdapter, use its setViewBinder() method. We will need to supply the method with an implementation of ViewBinder. ViewBinder is an interface that specifies setViewValue(), where the actual binding of a particular date element to particular view happens.

``SimpleCursorAdapter``提供了一个``setViewBinder()``方法为它的业务逻辑提供扩展，它取一个``ViewBinder``的实现作为参数。``ViewBinder``是个接口，里面声明了一个``setViewValue()``方法，也就是在这里，它将具体的日期元素与View真正地绑定起来。

% Again, we discovered setViewBinder() feature of this SimpleCursorAdapter framework class by reading reference documentation for it.

同样，我们可以在官方文档中发现这一特性。

% In our final iteration of TimelineAdapter, we create a custom ViewBinder as a constant and attach it to the stock SimpleCursorAdapter.

如下即针对``TimelineAdapter``的最后一轮迭代，我们实现一个自定义的``ViewBinder``作为常量，并把它交给``SimpleCursorAdapter``。

**Example 10.8. TimelineActivity.java with ViewBinder**
{CODE}
  ...

  @Override
  protected void onResume() {
    ...
    adapter.setViewBinder(VIEW_BINDER); // #{1}
    ...
  }

  // View binder constant to inject business logic that converts a timestamp to
  // relative time
  static final ViewBinder VIEW_BINDER = new ViewBinder() { // #{2}

    public boolean setViewValue(View view, Cursor cursor, int columnIndex) { // #{3}
      if (view.getId() != R.id.textCreatedAt)
        return false; // #{4}

      // Update the created at text to relative time
      long timestamp = cursor.getLong(columnIndex); // #{5}
      CharSequence relTime = DateUtils.getRelativeTimeSpanString(view
          .getContext(), timestamp); // #{6}
      ((TextView) view).setText(relTime); // #{7} 

      return true; // #{8}
    }

  };

  ...
{/CODE}

% + We attach a custom ViewBinder instance to our stock adapter. VIEW_BINDER is defined further down in our code.
% + The actual implementation of a ViewBinder instance. Notice that we are implementing it as an inner class. That’s because there’s no reason for any other class to use it and thus shouldn’t be exposed to the outside world. Also notice that it is static final, meaning that it’s a constant.
% + The only method that we need to provide is setViewValue(). This method is called for each data element that needs to be bound to a particular view.
% + First we check whether this view is the view we care about, i.e., our TextView representing when the status was created. If not, we return false, which causes the adapter to handle the bind itself in the standard manner. If it is our view, we move on and do the custom bind.
% + We get the raw timestamp value from the cursor data.
% + Using the same Android helper method we used in our previous example, DateUtils.getRelativeTimeSpanString(), we convert the timestamp to the human-readable format. This is that business logic that we are injecting.
% + Update the text on the actual view.
% + Return true so that SimpleCursorAdapter does not process bindView() on this element in its standard way.

+ 将一个自定义的ViewBinder实例交给对应的Adapter。VIEW_BINDER的定义在后面给出。
+ ViewBinder的实现部分。留意它是一个内部类，外面的类不可以使用它，因此不必把它暴露在外。同时留意下``static final``表明它是一个常量。
+ 我们需要实现的唯一方法即``setViewValue()``。它在每条数据与其对应的View绑定时调用。
+ 首先检查这个View是不是我们关心的，也就是表示消息创建时间的那个TextView。若不是，返回false，Adapter也就按其默认方式处理绑定；若是，则按我们的方式继续处理。
+ 从``cursor``中取出原始的timestamp数据。
+ 使用上个例子相同的辅助函数``DateUtils.getRelativeTimeSpanString()``将时间戳(timestamp)转换为人类可读的格式。这也就是我们扩展的业务逻辑。
+ 更新对应View中的文本。
+ 返回true，因此``SimpleCursorAdapter``不再按照默认方式处理绑定。 



% ==Updating Manifest File==
==更新Manifest文件==

% Now that we have the TimelineActivity, it would make sense to make it "the main" activity for Yamba application. After all, users are more likely to want to check what their friends are doing than to update their own status.

好，现在我们有了``TimelineActivity``，大可让它作为Yamba程序的“主界面”。毕竟比起自言自语，用户更喜欢关注朋友的动态。

% To do that, we need to update the manifest file. As usual, we’ll list TimelineActivity within the <activity> element in the AndroidManifest.xml file, just as we added preference activity to the manifest file in the section called “Update Manifest File”:

这就需要更新manifest文件了。同原先一样，我们将TimelineActivity列在AndroidManifest.xml文件的<activity>元素中。可参考"Update Manifest File"一节中添加选项界面时的情景。

{CODE}
<activity android:name=".TimelineActivity" />
{/CODE}

% Now, in order to make TimelineActivity the main entry point into our application, we need to register it to respond to certain intents. Basically, when the user clicks to start your application, the system sends an intent. You have to define an activity to "listen" to this intent. The activity does that by filtering the intents using an IntentFilter. In XML, this is within the <intent-filter> element and it usually contains at least an <action> element representing the actual intent action we’re interested in.

要把它设为程序的“主界面”，我们需要为它注册到特定的Intent。通常情况是，用户点击启动你的程序，系统就会发送一个Intent。你必须有个Activity“侦听”到这个Intent才行，因此Andorid提供了IntentFilter，使之可以过滤出各自感兴趣的Intent。在XML中，它通过``<intent-filter>``元素表示，其下至少含有一个``<action>``元素，以表示我们感兴趣的Intent。

% You may have noticed that StatusActivity had some extra XML compared to PrefsActivity. The extra code is the intent filter block, along with the action that it’s filtering for.

你可以注意到，``StatusActivity``比``PrefsActivity``多出了一段XML代码，这便是IntentFilter的部分。

% There is a special action named android.intent.action.MAIN that simply indicates that this is the main component that should be started when the user wants to start your application. Additionally, there’s a <category> element that tells the system that this application should be added to the main Launcher application so that the user can see the app icon along with all the other icons, click on it, and start it. This category is defined as android.intent.category.LAUNCHER.

里面有个特殊的``action``，``android.intent.action.MAIN``，即指明了在用户打算启动我们的程序时首先启动的组件。除此之外还有个``<category>``元素，用以通知系统这个程序会被加入到``main Launcher``之中，这一来用户就可以见到我们程序的图标，点击即可启动。这个目录(category)的定义就是``android.intent.category.LAUNCHER``。

% So, to make TimelineActivity the main entry point, we simply list it and move the code from the StatusActivity declaration over to the TimelineActivity declaration.

好，要把``TimelineActivity``置为主入口，我们只需加上相应的声明，再把``StatusActivity``中的代码挪过去即可。

**Example 10.9. AndroidManifest.xml**
{CODE}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  android:versionCode="1" android:versionName="1.0" package="com.marakana.yamba5">
  <application android:icon="@drawable/icon" android:label="@string/app_name"
    android:name=".YambaApplication">

    <activity android:name=".TimelineActivity" android:label="@string/titleTimeline">
      <intent-filter> <!-- #{1} -->
        <action android:name="android.intent.action.MAIN" /> <!-- #{2} -->
        <category android:name="android.intent.category.LAUNCHER" /> <!-- #{3} -->
      </intent-filter>
    </activity>

    <activity android:name=".PrefsActivity" android:label="@string/titlePrefs" />
    <activity android:name=".StatusActivity" android:label="@string/titleStatus" /> <!-- #{4} -->

    <service android:name=".UpdaterService" />

  </application>
  <uses-sdk android:minSdkVersion="8" />

  <uses-permission android:name="android.permission.INTERNET" />
</manifest>
{/CODE}

% + <intent_filter> registers this particular activity with the system to respond to certain intents.
% + Tells the system that this is the main activity to start when users chooses to start your application.
% + The category LAUNCHER tells the Home application to add this application into the list of applications it displays in the launcher drawer.
% + StatusActivity no longer needs any intent filters.

+ ``<intent_filter>``将这个Activity所关心的Intent列出，并在系统中注册。
+ 通知系统，这就是用户启动时显示的主界面。
+ 目录``LAUNCHER``通知Home程序，将本程序的图标显示在Launcher中。
+ ``StatusActivity``就不需要IntentFilter了。


% ===Initial App Setup===
===程序初始化===

% Now, when the user runs our application, the Timeline screen will show up first. But unless the user knows she should set up the preferences and start the service, there will be no data and very little hand holding telling her what to do.

好，现在用户启动我们的程序就会首先看到Timeline界面。但是用户必须先设置个人选项并启动Service，否则就没有消息显示。这很容易让人摸不着头脑。

% One solution to that would be to check whether preferences exist, and if they do not, redirect the user to the Preference activity with a message what to do next.

一个解决方案是，在启动时检查用户的个人选项是否存在。若不存在，就跳到选项界面，并给用户一个提示，告诉她下一步该怎么做。

{CODE}
...
@Override
protected void onCreate(Bundle savedInstanceState) {
  ...
  // Check whether preferences have been set
  if (yamba.getPrefs().getString("username", null) == null) { // #{1}
    startActivity(new Intent(this, PrefsActivity.class)); // #{2}
    Toast.makeText(this, R.string.msgSetupPrefs, Toast.LENGTH_LONG).show(); // #{3}
  }
  ...
}
...
{/CODE}

% + We check whether one of the preferences have been set. In this case, I’ve shosen to check username because it’s likely to be set if any preferences at all are set. Since the first time user runs the application, the preferences do not exist, this means the value of username (or any other preference item we choose) will be null.
% + We start the PrefsActivity. Note that startActivity() will dispatch an intent to the system, but the rest of onCreate() will execute as well. This is good since we’re likely going to come back to the Timeline activity once we’re done setting up preferences.
% + We display a little pop-up message, i.e. a Toast telling the user what to do. This assumes that you have created the appropriate msgSetupPrefs in your strings.xml file, as usual.

+ 检查用户的个人选项是否设置。在这里先只检查``username``即可，因为有了``username``，往往就意味着所有个人选项都已设置。在第一次启动程序时个人选项还不存在，因此``username``(或者其它任意一项)肯定为null。
+ 启动``PrefsActivity``。留意这里的``startActivity()``调用给系统发送一个Intent，但并不会在这里退出``onCreate()``的执行。这一来就允许用户在设置完毕之后，可以回到Timeline界面。
+ 显示一条弹出消息(即Toast)，提示用户该怎么做。同前面一样，这里假定你在``strings.xml``中提供了``msgSetupPrefs``的定义。


===BaseActivity===

% Now that we have a Timeline activity, we need to give it an options menu, just as we did to our Status activity in the section called “Options Menu”. This is especially important because the Timeline activity is the entry point into our application and without the menu, the user cannot easily get to any other activity or start and stop the service.

现在我们有了Timeline界面，接下来需要一个选项菜单，就像在``Options Menu``一节中对``StatusActivity``所做的那样。这对Timeline界面来说很重要，因为作为主界面，要没有菜单，用户就没法访问其它界面或者控制Service的开关了。

% As one approach, we could copy and paste the code we already have from the Status activity, but that’s rarely a good strategy. Instead, we’ll do what we usually do: refactor the code. In this case, we can take out the common functionality from the Status activity and place it in another activity that will serve as the base. See Figure 10.2, “BaseActivity Refactor”.

要实现上述功能，我们可以把``StatusActivity``中相关的代码都复制粘贴过来，但这不是好办法。相反，我们应该优先考虑的是重构。在这里，我们可以将``StatusActivity``中相应的功能放在另一个``Activity``中，并使其作为基类。

**Figure 10.2. BaseActivity Refactor**

[images/10-BaseActivity.png]


% To do that, we’ll create a new class called BaseActivity and move the the common functionality into it. For us, the common functionality includes getting the reference to the YambaApplication object, as well as the onCreateOptionsMenu() and onOptionsItemSelected() methods that support the options menu.

我们新建一个类``BaseActivity``，然后把需要重用的代码挪到里面。这里重用的代码就是：获得``YambaApplication``对象引用、选项菜单的相关代码(``onCreateOptionsMenu()``和``onOptionsItemSelected()``)。

% ===Toggle Service===
===Service开关===

% While we’re at it, instead of having Start Service and Stop Service menu buttons, it would be nice to provide just one button that toggles between Start and Stop. To do that, we’ll change our menu and add onMenuOpened() to the base activity to dynamically update the title and images for this toggle item.

在这个地方分别提供开/关两个按钮，总不如只留一个按钮做开关更好。因此需要修改菜单，并为``BaseActivity``添加一个``onMenuOpened()``方法用以动态控制按钮文本以及图标的变化。

% First, we’ll update the menu.xml file to include our new toggle menu item. At the same time, we’ll remove the Start Service and Stop Service items because our toggle feature makes them obsolete.

首先修改//munu.xml//文件，添加新的菜单项，也就是开关按钮。这时原先启动/关闭Service的两个按钮已经没必要了，删除即可。

**Example 10.10. res/menu/menu.xml[]**
{CODE}
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

  <item android:id="@+id/itemStatus" android:title="@string/titleStatus"
    android:icon="@android:drawable/ic_menu_edit"></item>
  <item android:title="@string/titleTimeline" android:id="@+id/itemTimeline"
    android:icon="@android:drawable/ic_menu_sort_by_size"></item>
  <item android:id="@+id/itemPrefs" android:title="@string/titlePrefs"
    android:icon="@android:drawable/ic_menu_preferences"></item>
  <item android:icon="@android:drawable/ic_menu_delete"
    android:title="@string/titlePurge" android:id="@+id/itemPurge"></item>

  <!-- #{1} -->
  <item android:id="@+id/itemToggleService" android:title="@string/titleServiceStart"
    android:icon="@android:drawable/ic_media_play"></item>

</menu>
{/CODE}

% + This new itemToggleService now replaces both itemServiceStart and itemServiceStop.

+ 将原先的``itemServiceStart``与``itemServiceStop``替换为``itemToggleService``。


**Example 10.11. BaseActivity.java**
{CODE}
package com.marakana.yamba5;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.Toast;

/**
 * The base activity with common features shared by TimelineActivity and
 * StatusActivity
 */
public class BaseActivity extends Activity { // #{1}
  YambaApplication yamba; // #{2}

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    yamba = (YambaApplication) getApplication(); // #{3}
  }

  // Called only once first time menu is clicked on
  @Override
  public boolean onCreateOptionsMenu(Menu menu) { // #{4}
    getMenuInflater().inflate(R.menu.menu, menu);
    return true;
  }

  // Called every time user clicks on a menu item
  @Override
  public boolean onOptionsItemSelected(MenuItem item) { // #{5}

    switch (item.getItemId()) {
    case R.id.itemPrefs:
      startActivity(new Intent(this, PrefsActivity.class)
          .addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT));
      break;
    case R.id.itemToggleService:
      if (yamba.isServiceRunning()) {
        stopService(new Intent(this, UpdaterService.class));
      } else {
        startService(new Intent(this, UpdaterService.class));
      }
      break;
    case R.id.itemPurge:
      ((YambaApplication) getApplication()).getStatusData().delete();
      Toast.makeText(this, R.string.msgAllDataPurged, Toast.LENGTH_LONG).show();
      break;
    case R.id.itemTimeline:
      startActivity(new Intent(this, TimelineActivity.class).addFlags(
          Intent.FLAG_ACTIVITY_SINGLE_TOP).addFlags(
          Intent.FLAG_ACTIVITY_REORDER_TO_FRONT));
      break;
    case R.id.itemStatus:
      startActivity(new Intent(this, StatusActivity.class)
          .addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT));
      break;
    }
    return true;
  }

  // Called every time menu is opened
  @Override
  public boolean onMenuOpened(int featureId, Menu menu) { // #{6}
    MenuItem toggleItem = menu.findItem(R.id.itemToggleService); // #{7}
    if (yamba.isServiceRunning()) { // #{8}
      toggleItem.setTitle(R.string.titleServiceStop);
      toggleItem.setIcon(android.R.drawable.ic_media_pause);
    } else { // #{9}
      toggleItem.setTitle(R.string.titleServiceStart);
      toggleItem.setIcon(android.R.drawable.ic_media_play);
    }
    return true;
  }

}
{/CODE}

% + BaseActivity is an Activity.
% + We declare the shared YambaApplication to make it accessible to all the other subclasses.
% + In onCreate(), we get the reference to this yamba.
% + onCreateOptionsMenu() is moved here from StatusActivity.
% + onOptionsItemSelected() is also moved over from StatusActivity. Notice, however, that it now checks for itemToggleService instead of start and stop service items. Based on state of the service, which we know from the flag in yamba, we request either to start or to stop the Updater service.
% + onMenuOpened() is the new method called by the system when the options menu is opened. This is a good callback for us to implement the toggle functionality. We’re given the menu object that represents the options menu.
% + Within the menu object, we find our new toggle item so that we can update it based on the current state of the Updater service.
% + We check whether the service is already running, and if it is, we set the appropriate title and icon for the toggle item. Notice that here we’re setting up the title and icon programmatically using the Java APIs, instead of the XML which we used initially to set up the menu in menu.xml.
% + If the service is stopped, we set the icon and title so that user can click on it and start the service. This way our single toggle button communicates whatever state the service is currently in.

+ ``BaseActivity``是个Activity。
+ 声明一个共享的YambaApplication对象，使之可为所有子类访问。
+ 在``onCreate()``中获得``yamba``的引用。
+ 将``StatusActivity``的``onCreateOptionsMenu``挪到了这里。
+ ``onOptionsItemSelected``也是同样来自``StatusActivity``。不过留意下这里的变动：它不再检查启动/停止Service的两个条目，改为检查``itemToggleService``一个条目。通过yamba中的标志变量我们可以得到Service的运行状态，基于此，决定启动还是关闭。
+ ``onMenuOpened()``是个新加入的方法，它在菜单打开时为系统所调用，参数``menu``即我们的选项菜单。我们可以在这里控制开关的显示。
+ 在``menu``对象中找到我们新建的开关条目。
+ 检查Service是否正在运行，如果是，则设置对应的标题与图标。留意我们在这里是通过Java的API手工地修改GUI的内容，而无关xml。
+ 如果Service没有运行，则设置对应的标题与图标，用户点击它即可启动Service。这样我们就实现了开关按钮随Service状态的不同而变化。


好，已经有了``BaseActivity``类，接下来修改``TimelineActivity``也使用它。如下为``TimelineActivity``的完整实现：

**Example 10.12. TimelineActivity.java, final version**
{CODE}
package com.marakana.yamba5;

import android.content.Intent;
import android.database.Cursor;
import android.os.Bundle;
import android.text.format.DateUtils;
import android.view.View;
import android.widget.ListView;
import android.widget.SimpleCursorAdapter;
import android.widget.TextView;
import android.widget.Toast;
import android.widget.SimpleCursorAdapter.ViewBinder;

public class TimelineActivity extends BaseActivity { // #{1}
  Cursor cursor;
  ListView listTimeline;
  SimpleCursorAdapter adapter;
  static final String[] FROM = { DbHelper.C_CREATED_AT, DbHelper.C_USER,
      DbHelper.C_TEXT };
  static final int[] TO = { R.id.textCreatedAt, R.id.textUser, R.id.textText };

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.timeline);

    // Check if preferences have been set
    if (yamba.getPrefs().getString("username", null) == null) { // #{2}
      startActivity(new Intent(this, PrefsActivity.class));
      Toast.makeText(this, R.string.msgSetupPrefs, Toast.LENGTH_LONG).show();
    }

    // Find your views
    listTimeline = (ListView) findViewById(R.id.listTimeline);
  }

  @Override
  protected void onResume() {
    super.onResume();

    // Setup List
    this.setupList(); // #{3}
  }

  @Override
  public void onDestroy() {
    super.onDestroy();

    // Close the database
    yamba.getStatusData().close(); // #{4}
  }

  // Responsible for fetching data and setting up the list and the adapter
  private void setupList() { // #{5}
    // Get the data
    cursor = yamba.getStatusData().getStatusUpdates();
    startManagingCursor(cursor);

    // Setup Adapter
    adapter = new SimpleCursorAdapter(this, R.layout.row, cursor, FROM, TO);
    adapter.setViewBinder(VIEW_BINDER); // #{6}
    listTimeline.setAdapter(adapter);
  }

  // View binder constant to inject business logic for timestamp to relative
  // time conversion
  static final ViewBinder VIEW_BINDER = new ViewBinder() { // #{7}

    public boolean setViewValue(View view, Cursor cursor, int columnIndex) {
      if (view.getId() != R.id.textCreatedAt)
        return false;

      // Update the created at text to relative time
      long timestamp = cursor.getLong(columnIndex);
      CharSequence relTime = DateUtils.getRelativeTimeSpanString(view
          .getContext(), timestamp);
      ((TextView) view).setText(relTime);

      return true;
    }

  };
}
{/CODE}

% + For starters, we now subclass our BaseActivity instead of just of the system’s Activity. This way we inherit the yamba object as well as all the support for the options menu.
%NOTE: for starters是俚语，to begin with
% + This is where we check whether preferences are already set. If not, we’ll redirect the user to the Preference activity first.
% + On resuming this activity, we set up the list. This is a private method, shown further down.
% + When this activity is closed, we want to make sure we close the database to release this resource. The database is opened by the call to getStatusUpdates() in the yamba application.
% + setupList() is the convenience method that gets the data, sets up the adapter, and connects it all to the list view.
% + This is where we attach the view binder to the list, as discussed already in the section called “ViewBinder: A Better Alternative to TimelineAdapter”.
% + ViewBinder is defined here.

+ 首先将基类由系统提供的``Activity``改为我们的``BaseActivity``。由此也就继承来了yamba对象，以及选项菜单的相关支持。
+ 在这里检查用户的个人选项是否存在，若不存在，则切换到选项界面。
+ 在界面显示时，初始化消息列表。这是个私有方法，定义在后面。
+ 我们希望在界面关闭时，关闭数据库并释放资源。数据库是在``yamba``对象中的``getStatusUpdates()``方法中打开的。
+ 辅助方法``setupList()``用以获取数据、设置Adapter并将其绑定于ListView。
+ 在这里将ViewBinder绑定于List。参见["ViewBinder：TimelineAdapter之外的更好选择" #]一节。
+ ViewBinder的定义。


% At this point, we’ve done a lot of the refactoring work on our Timeline activity. We can also simplify the Status activity by cutting out the code related to the options menu. This makes it simpler and helps separate functional concerns among BaseActivity, StatusDate, and TimelineActivity.

到这里，我们已经将``TimelineActivity``重构的差不多了。按照如上的步骤，我们可以进一步简化``StatusActivity``，将选项菜单相关的代码清掉，从而使得``BaseActivity``、``StatusDate``、``TimelineActivity``的职责更加分明。

% **Figure 10.3, “TimelineActivity” shows what the final Timeline activity screen looks like.**

//Figure 10.3, “TimelineActivity”// 展示了Timeline界面最后的样子。

**Figure 10.3. TimelineActivity**

[images/10-TimelineActivity-3.png]

==总结==

% At this point, Yamba can post a new status as well as list statuses of our friends. Our application is complete and usable.

到这里，Yamba除了可以发信息，也可以阅读朋友的消息了。我们的程序仍是完整可用的。

% Figure 10.4, “Yamba Completion” illustrates what we have done so far as part of the design outlined in Figure 5.4, “Yamba Design Diagram”.

Figure 10.4 //"Yamba Completion"//展示了我们目前已完成的部分。完整图参见 Figure 5.4, //Yamba Design Diagram//。

**Figure 10.4. Yamba Completion**

[images/10-Yamba-5.png]

