% 
%

% =System Services=
=系统服务=[ch13]

% Like many modern operating systems, Android comes with a number of system services that are always on, always running, and readily available to developers to tap into. These system services include things like Location service, Sensor service, WiFi service, Alarm service, Telephony service, Bluetooth service, and so on. System services are started at boot time and are guaranteed to be running by the time your application launches.

同其它现代操作系统一样，Android也内置了一系列的系统服务。它们都是随着系统启动，并一直处于运行状态，随时可供开发者访问。比如Location服务、Sensor服务、WiFi服务、Alarm服务、Telephony服务、Bluetooth服务等等。

% In this chapter, we’ll see how we can use some of the system services to further expand the Yamba application. First we’ll take a look at the Sensor service in a small example in order to demonstrate some of the concepts that are common to most of the system services. Then we’ll add support for location information to our status updates via the Location service.

本章介绍几个常见的系统服务，并思考如何将它们应用到Yamba。我们先在一个小例子里引入Sensor服务，借以观察系统服务的一般特性，然后通过Location服务为Yamba添加地理坐标的功能。

% Additionally, we’re going to refactor the Yamba application to take advantage of Intent Service support. This will demonstrate how to use Alarm service and will make our Updater slightly more efficient and simpler.

另外，我们会重构Yamba的代码来获得Intent服务的支持，继而引出Alarm服务，并凭借它优化Updater的实现。

==Compass Demo==

% To start with system services, we are going to look at a simple, self-contained example of a compass application. This application uses the Sensor service to get updates from the orientation sensor and use its information to rotate a Rose, our custom UI component. The Sensor service is very typical of system services and a relatively easy one to understand.

理解系统服务，我们先从一个简单的样例——指南针(Compass)——开始。它可以通过Sensor服务获得传感器的输出，旋转屏幕上的表盘(Rose)显示方位。Sensor服务是个有代表性的系统服务，也不难懂。

% To build this example, we’ll create an activity that will get the Sensor service and register for updates from a particular sensor. Next, we’ll build the Rose that will rotate on the screen based on the sensor readings.

在例子中，我们先创建一个Activity，由它来访问Sensor服务，订阅来自传感器的输出。然后自定义一个表盘控件(Rose)，使之可以依据从传感器得到的数据旋转一定的角度。

%NOTE: Compass Rose,表盘。翻成“玫瑰”就笑话大了。

% ===Common Steps in Using System Services===
===使用系统服务的一般步骤===

% To get any system service, issue the getSystemService() call. This returns a Manager object representing that system service, which you then use to access the service. Most system services work on some sort of publish/subscribe mechanism. In other words, you generally register your app for notifications from that service and provide your own callbacks methods that the service will invoke when an event happens. To do this in Java, create a Listener that implements an interface so that the service can call the callback methods.

使用系统服务，就调用``getSystemService()``。它返回一个表示系统服务的Manager对象，随后凭它就可以访问系统服务了。系统服务大多都是发布/订阅的接口，使用起来大约就是准备一个回调方法，将你的程序注册到相应的系统服务，然后等它的通知。在Java中的通行做法是，实现一个内含回调方法的侦听器(Listener)，并把它传递给系统服务。

% Keep in mind that requesting notifications from a system service can be costly in terms of the battery usage. For example, getting a GPS signal or processing sensor updates takes a lot of energy from the device. To preserve the battery, we typically want to be doing the work of processing updates only when the user is looking at the activity itself. In terms of the Activity lifecycle (see the section called “Activity Lifecycle”), this means we want to get the notifications only while in the Running state (see the section called “Running State”).

有一点需要注意，那就是访问系统服务可能会比较费电。比如访问GPS数据或者传感器操作，都会额外消耗设备的电能。为了节约电能，我们可以仅在界面激活时进行传感器操作，使不必要的操作减到最少。用Activity生命周期(参见"Activity生命周期"一节)的说法就是，我们仅在Running状态中响应这些操作。

% To ensure that you request service updates only while in the Running state, register for updates in onResume() and unregister in onPause(). This is because all roads into the Running state go via onResume() and all roads out of it go via onPause(). In certain other situations, you may want to cast the net wider and have the activity be registered between onStart() and onStop(), or even between onCreate() and onDestroy(). In our case, we don’t want to register in onCreate() because it would waste a lot of battery and processing time by making us listen and process sensor updates even when our activity is not in the foreground. You can now see how understanding the Activity lifecycle plays an important role in optimizing usage of system services for the battery consumption.

进入Running状态之前必经``onResume()``，离开Running状态之后必经``onPause()``。因此要保证只在Running状态中使用系统服务，就在``onResume()``中注册到系统服务，并在``onPause()``中注销即可。在某些情景中，我们可能希望将Activity注册在``onStart()``与``onStop()``之间，甚至``onCreate()``与``onDestroy()``之间，好让它在整个生命周期里都在注册中。但在这里，我们并不希望在``onCreate()``中就开始使用系统服务，因为``onCreate()``时，Activity还未显示，在此注册到系统服务只会空耗电能。由此可以看出，对Activity的生命周期有所理解，对省电是肯定有帮助的。

% ===Getting Updates From the Compass===
===获取指南针的更新===

% To code our Compass demo application, we get SensorManager, the class that represents the Sensor system service. We make our main activity implement SensorEventListener so that we can register it (i.e. this) to get updates for a specific sensor. We register and unregister the listener in onResume() and onPause() respectively. To implement the sensor listeners, our activity provides onAccuracyChanged() and onSensorChanged(). The former is a requirement, but we’ll leave it empty because the accuracy of the orientation sensor is not expected to change. The latter call is what’s really of interest to us.

表示Sensor系统服务的类是SensorManager，接下来就是跟它打交道了。在Activity中实现一个SensorEventListener，将它注册到SensorManager中即可订阅特定传感器的更新。为了省电，我们将传感器操作安排在``onResume()``与``onPause()``之间。然后实现侦听器(Listener)，在Activity中提供``onAccuracyChanged()``和``onSensorChanged()``两个方法。前者必须，后者可选。不过我们对传感器的精度(Accuracy)并无兴趣——因为方向传感器(Orientation Sensor)的精度在中间并不会发生变化，我们真正感兴趣的是它的数据。所以在这里我们将前者留空，而提供后者的实现。

% When the orientation sensor changes, the Sensor service calls back our sensor listener via onSensorChanged() and reports the new sensor data. The data always comes back as an array of float values that represent degrees and therefore range from 0 to 359. In the case of orientation sensor, the elements represent the following dimensions, illustrated in Figure 13.1, “Axis”:

在方向传感器状态变化时，Sensor服务会回调``onSensorChanged()``，通知侦听器(Listener)得到了新数据。这些数据都是0~359之间的浮点数组成的数组。方向角(azimuth)与磁偏角(pitch与roll)，构成了下边的坐标，如图13.1：

%NOTE: 磁偏角：磁针指示的方向并不是正南正北，而是微偏西北和东南，这在科学上称为磁偏角。

% Index [0], the azimuth:: The amount of rotation around the Z axis from the vertical position around the back and then around the bottom toward the front. 
% Index [1], the pitch:: The amount of rotation around the X axis from the front to the left and then the around the back toward the right. 
% Index [2], the roll: The amount of rotation around the Y axis from the vertical position to the left and then the around the bottom toward the right.

- 下标[0]，方位角(azimuth)：垂直于Z轴，沿Y轴正方向顺时针旋转的角度。
- 下标[1]，横摇(pitch)：垂直于Y轴，沿Z轴正方向顺时针旋转的角度。
- 下标[2]，纵摇(roll)：垂直于Y轴，沿X轴正方向顺时针旋转的角度。


% For the Compass demo, we are interested only in the first element, i.e., the azimuth. The data returned by each sensor has a different meaning, and you should look up the particulars in the documentation at http://d.android.com/reference/android/hardware/SensorManager.html.

我们的指南针只关心第一个元素，也就是方位角。不同传感器的返回值的含义各有不同，对此需要查询相应的文档 http://d.android.com/reference/android/hardware/SensorManager.html。

**Figure 13.1. Axis**

[images/13-axis_globe_inverted.png]


% ===Compass Main Activity===
===Compass的主界面===

% The main Compass activity sets the Rose as its only widget on the screen. It also registers with SensorManager to listen to sensor events, and updates the Rose orientation accordingly.

指南针的主界面里只有一个控件，那就是表盘(Rose)。它也将自己注册给SensorManager，监听传感器的事件，调整表盘的角度。

**Example 13.1. Compass.java**

{CODE}
package com.marakana;

import android.app.Activity;
import android.content.res.Configuration;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.Bundle;
import android.util.Log;
import android.view.Window;
import android.view.WindowManager;

// implement SensorListener
public class Compass extends Activity implements SensorEventListener { //#{1}
  SensorManager sensorManager; //#{2}
  Sensor sensor;
  Rose rose;

  /** Called when the activity is first created. */
  @Override
  public void onCreate(Bundle savedInstanceState) { //#{3}
    super.onCreate(savedInstanceState);

    // Set full screen view #{4}
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
        WindowManager.LayoutParams.FLAG_FULLSCREEN);
    requestWindowFeature(Window.FEATURE_NO_TITLE);

    // Create new instance of custom Rose and set it on the screen
    rose = new Rose(this); //#{5}
    setContentView(rose); // #{6}

    // Get sensor and sensor manager
    sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE); // #{7}
    sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION); // #{8}

    Log.d("Compass", "onCreated");
  }

  // Register to listen to sensors
  @Override
  public void onResume() {
    super.onResume();
    sensorManager.registerListener(this, sensor,
        SensorManager.SENSOR_DELAY_NORMAL); // #{9}
  }

  // Unregister the sensor listener
  @Override
  public void onPause() {
    super.onPause();
    sensorManager.unregisterListener(this); // #{10}
  }

  // Ignore accuracy changes
  public void onAccuracyChanged(Sensor sensor, int accuracy) { // #{11}
  }

  // Listen to sensor and provide output
  public void onSensorChanged(SensorEvent event) { // #{12}
    int orientation = (int) event.values[0]; // #{13}
    Log.d("Compass", "Got sensor event: " + event.values[0]);
    rose.setDirection(orientation); // #{14}
  }

  @Override
  public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
  }

}
{/CODE}

% + Since Compass listens to sensor events, it needs to implement the SensorEventListener interface.
% + We define local variable for the sensor, the sensor manager, and the Rose.
% + Because getting access to the sensor is a one-time activity, we do it when our app is created.
% + The window manager flags set the activity into full-screen mode.
% + We create a new instance of the Rose widget, our custom compass rose.
% + In this case, the activity content is the single Rose widget. This is unlike the usual reference to an XML layout resource.
% + We get the sensor manager from the system service.
% + From the sensor manager, we can obtain the actual sensor object that we are interested in.
% + We register to listen to sensor updates in activity’s onResume() method, as described earlier.
% + We unregister from sensor updates in onPause(), the counterpart to onResume().
% + onAccuracyChanged() is implemented because it is required by the SensorEventListener interface. but is left empty as explained earier.
% + onSensorChanged() is called whenever the sensor changes, indicating a rotation of the device in some direction. The particular information about the change is stored in SensorEvent.
% + We are interested in the first element of the array of new values reported.
% + Once we have the new orientation, we update our Rose widget to rotate accordingly.

+ Compass会监听来自传感器的事件，因此需要提供SensorEventListener接口的实现。
+ 定义几个私有变量，分别表示传感器对象(sensor)，SensorManager与表盘(rose)。
+ 初始化sensor是个一次性的操作，因此我们把它放在``onCreate()``中执行。
+ 设置此Activity的状态为全屏。
+ 创建一个Rose控件的实例，这是我们自定义的控件。
+ 这里Activity里面唯一的控件就是Rose，这与通常引用一个XML资源表示的Layout有所不同。
+ 获得SensorManager对象。
+ 通过SensorManager对象，选择我们关心的传感器。
+ 同前面所说，在``onResume()``中将自己注册到系统服务，侦听传感器的输出。
+ 对应``onResume()``，在onPause()``中注销系统服务。
+ 依然提供``onAccuracyChanged()``的实现，因为这对SensorEventListener接口来说是必须的。但是留空，前面已有解释。
+ 传感器在状态改变时会回调``onSensorChanged()``，表示设备的方向发生变化。具体的角度信息储存在``SensorEvent``对象中。
+ 我们只关心返回值中的第一个元素。
+ 得到新的方向信息，更新表盘的角度。


{NOTE}
% The way a device reports sensor data can be very erratic, coming at uneven intervals. There are ways to suggest to the system how frequently we’d like the sensor updates, but these are just suggestions and not a guarantee. Also, sensors are not supported by the emulator, so to really test your application, you’ll need a physical device with support for orientation sensor. Most Android phones have that support.

传感器输出的数据流可能是不稳定的，接到数据的时间间隔不可预知。我们可以为传感器提供一个建议的时间间隔，但只是建议，不是强制。而且仿真器没有提供传感器的支持，因此要测试这个程序就需要一台拥有方向传感器的真机。好在多数Android手机都有这一功能。
{/NOTE}

% ===Custom Rose Widget===
===自定义的表盘控件===

% Rose is our custom UI widget showing the rose of a compass that can be rotated like a real compass. Every UI widget in Android needs to be a subclass of View. But since this is an image, we’ll start from a higher starting point, in this case the ImageView class, which is a View. By subclassing ImageView, our Rose inherits some useful methods to load an image and draw it on the screen.

Rose是我们自定义的UI控件，它可以旋转，表示指南针的表盘。Android中的任何UI控件都是View的子类。Rose的主要部分是一个图片，这一来我们可以让它继承自ImageView类，在较高的层面上实现它，从而可以使用原有的方法实现装载并显示图片。

% With any custom UI widget, one of the most important methods is onDraw(), which draws the widget onto a Canvas that is provided to the method. In case of our Rose, we rotate this canvas around its middle point for the same number of degrees as reported by the orientation sensor. Next, we draw the image onto this rotated sensor as it would have normally be drawn by the super class. The result is a rotated compass rose representing the direction we are pointing to.

自定义一个UI控件，``onDraw()``方法最为重要。它负责控件的绘制与显示。我们需要覆盖父类的逻辑，使图片可以按圆心旋转一定的度数，以表示指南针的方位。

**Example 13.2. Rose.java**

{CODE}
package com.marakana;

import android.content.Context;
import android.graphics.Canvas;
import android.widget.ImageView;

public class Rose extends ImageView { //#{1}
  int direction = 0;

  public Rose(Context context) {
    super(context);

    this.setImageResource(R.drawable.compassrose); // #{2}
  }

  // Called when component is to be drawn
  @Override
  public void onDraw(Canvas canvas) { // #{3}
    int height = this.getHeight();  // #{4}
    int width = this.getWidth();

    canvas.rotate(direction, width / 2, height / 2); // #{5}
    super.onDraw(canvas); // #{6}
  }

  // Called by Compass to update the orientation
  public void setDirection(int direction) { // #{7}
    this.direction = direction;
    this.invalidate(); // request to be redrawn #{8}
  }

}
{/CODE}

% + Our widget has to be a subclass of View, but since our widget is an image, we get more functionality by starting from ImageView.
% + ImageView already knows how to set an image as its content. We just specify to super which image resource to use. Note that compassrose.jpg is in our /res/drawable folder.
% + onDraw() is the method that the layout manager calls to have each widget draw itself. The layout manager passes the Canvas to this method. This method is where you typically do any custom drawing to the canvas.
% + Once we have the canvas, we can figure out its size.
% + We simply rotate the entire canvas for some amount (in degrees) around its mid point.
% + We tell super to draw the image on this rotated canvas. At this point we have our rose drawn at the proper angle.
% + setDirection() is called by the Compass activity to update the direction of the rose based on the values that sensor manager reported.
% + Calling invalidate() on a view marks it for redrawing, which happens later via a call to onDraw().

+ 我们的控件必须是View的子类。不过它大体就是一张图片，可以让它继承自ImageView，得以使用现有的功能。
+ ImageView本身已有设置图片内容的方法，我们需要做的就是为它指明相应的图片。留意，compassrose.jpg文件在/res/drawable之下。
+ ``onDraw()``由Layout Manager负责调用。它会传递过来一个Canvas对象，你可以在这里执行自定义的绘制操作。
+ 已获得Canvas对象，可以计算自身的宽高。
+ 简单地以中点为圆心，旋转整个Canvas(按度数)。
+ 通知super将图片绘制到这个旋转了的Canvas上。到这里表盘就显示出来了。
+ ``setDirection()``由Compass负责调用，它会根据传感器中获得的数据调整Rose的方向。
+ 对View调用``invalidate()``，就可以要求它重绘。也就是在稍后调用``onDraw()``。


% At this point, your compass application is working. The compass rose should be pointing north, more or less, when the device is held upright as usual. Keep in mind that you should run this application on a physical device as the emulator doesn’t support.

到这里，指南针程序已经可用了。在设备横放时，表盘应大致指向北方。仿真器没有传感器的支持，因此这个程序只能在真机上运行。


% ==Location Service==
==Location服务==

% Now that you have seen how the sensor manager works, we can look at the Location API, another system service provided by Android. Just like sensors, the Location API is supported via the Location manager. And just like sensors, we get the Location manager via a getSystemService() call.

前面已对SensorManager的工作方式有所了解，接下来看下Location服务的API。同Sensor服务类似，使用Location服务是通过LocationManager，而且也是通过getSystemService()获取它的引用。

% Once we have access to the Location service, we need to register a Location listener with it so the service can call back when there’s a change in location. Again, we’ll do this by implementing a Location listener interface.

使用Location服务，我们需要传递给它一个侦听器(Listener)，这一来在位置改变的时候可以作出响应。同前面相似，我们在这里实现一个LocationListener接口。

% If you recall from the section called “Common Steps in Using System Services”, processing GPS and other location updates can be very taxing for the battery. To minimize the battery consumption, we want to listen to location updates only while in the Running state. To do that, we’ll register for the updates in onResume() and unregister in onPause(), taking the advantage of the Activity lifecycle.

//"使用系统服务的一般步骤"//一节曾提到，使用GPS服务或者其它位置操作都是非常费电的。为尽量地节约电能，我们只在Running状态中使用Location服务。因此利用Activity生命周期的设定，将它限制在``onResume()``与``onPause()``之间。

===Where Am I? Demo===

% This example illustrates how to use location-based services in Android. First, we use LocationManager to figure out our current location based on the resources in the environment available to the device, such as GPS or a wireless network. Secondly, we use Geocoder to convert this location to an address.

使用这个例子展示Android中位置服务的用法。首先通过LocationManager利用可用的信息源(GPS或者无线网)获取当前的位置信息，然后使用Geocoder将它转换为人类可读的地理地址。

====The Layout====

% The layout for this example is trivial. Our resource file provides a TextView widget for the title and another TextView widget for the output. Since the output could be longer than the screen size, we wrap the output in a ScrollView widget.

本例的Layout不是我们关注的重点。里面只有一个表示标题的TextView控件，和一个表示输出的TextView控件。其中输出可能会比较长，因此把它包在一个ScrollView里。

**Example 13.3. res/layout/main.xml**

{CODE}
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:layout_height="fill_parent" android:layout_width="fill_parent"
  android:background="#fff" android:orientation="vertical">
  <!-- #{1} -->
  <TextView android:layout_width="wrap_content"
    android:layout_height="wrap_content" android:layout_gravity="center"
    android:textColor="#333" android:textSize="30dp" android:text="@string/title"></TextView>
  <!-- #{2} -->
  <ScrollView android:layout_height="fill_parent"
    android:layout_width="fill_parent">
    <!-- #{3} -->
    <TextView android:textColor="#333" android:layout_gravity="center"
      android:layout_height="fill_parent" android:layout_width="fill_parent"
      android:gravity="center" android:textSize="25dp" android:text="Waiting..."
      android:id="@+id/textOut"></TextView>
  </ScrollView>
</LinearLayout>
{/CODE}

% + The title for our application.
% + A ScrollView to enable scrolling if the output grows beyond the size of the screen.
% + A TextView to represent the output. It will be programmatically set from the WhereAmI activity.

+ 程序的标题。
+ 输出可能会比较长，甚至超过屏幕的尺寸。因此，通过ScrollView为它加一个滚动条。
+ 表示输出的TextView，``WhereAmI``界面中唯一的动态部分。


% ====The Activity for our Location Listener====
====作为LocationListener的Activity====

% This is our main activity, which sets up the screen, connects to LocationManager, and uses the Geocoder to figure out our address. The LocationManager uses location providers, such as GPS or Network, to figure out our current location. The location is expressed as latitude and longitude values. The Geocoder searches an online database for known addresses in the vicinity of the location provided. It may come up with multiple results, some more specific than others.

这就是我们唯一的Activity。我们将在这里初始化界面，连接到LocationManager，然后使用Geocoder检索我们的地理地址。LocationManager可以通过不同的Location信息源(比如GPS或者网络)来获得我们的当前位置，以经纬度的格式返回。Geocoder以此检索在线的位置数据库，即可获得当前位置的地理地址。检索的结果可能有多个，精度不一。

**Example 13.4. WhereAmI.java**

{CODE}
package com.marakana;

import java.io.IOException;
import java.util.List;

import android.app.Activity;
import android.location.Address;
import android.location.Geocoder;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class WhereAmI extends Activity implements LocationListener { // #{1}
  LocationManager locationManager; // #{2}
  Geocoder geocoder; // #{3}
  TextView textOut; // #{4}

  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    textOut = (TextView) findViewById(R.id.textOut);

    locationManager = (LocationManager) getSystemService(LOCATION_SERVICE); // #{5}
    geocoder = new Geocoder(this); // #{6}

    // Initialize with the last known location
    Location lastLocation = locationManager
        .getLastKnownLocation(LocationManager.GPS_PROVIDER); // #{7}
    if (lastLocation != null)
      onLocationChanged(lastLocation);
  }

  @Override
  protected void onResume() { // #{8}
    super.onRestart();
    locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 1000,
        10, this);
  }

  @Override
  protected void onPause() { // #{9}
    super.onPause();
    locationManager.removeUpdates(this);
  }

  // Called when location has changed
  public void onLocationChanged(Location location) { // #{10}
    String text = String.format(
        "Lat:\t %f\nLong:\t %f\nAlt:\t %f\nBearing:\t %f", location
            .getLatitude(), location.getLongitude(), location.getAltitude(),
        location.getBearing()); // #{11}
    textOut.setText(text);

    // Perform geocoding for this location
    try {
      List<Address> addresses = geocoder.getFromLocation(
          location.getLatitude(), location.getLongitude(), 10); // #{12}
      for (Address address : addresses) {
        textOut.append("\n" + address.getAddressLine(0)); // #{13}
      }
    } catch (IOException e) {
      Log.e("WhereAmI", "Couldn't get Geocoder data", e);
    }
  }

  // Methods required by LocationListener 
  public void onProviderDisabled(String provider) {
  }

  public void onProviderEnabled(String provider) {
  }

  public void onStatusChanged(String provider, int status, Bundle extras) {
  }

}
{/CODE}

% + Notice that WhereAmI implements LocationListener. This is the interface that LocationManager uses to notify us of changes to location.
% + Local reference to LocationManager.
% + Local reference to Geocoder.
% + textOut is the text view to which we print our output to for the user to see.
% + We get the local reference to LocationManager by asking the context to get the location manager system service. For a reference on context, see the section called “Application Context”.
% + We create a new instance of Geocoder and pass the current context to it.
% + The Location manager memorizes its last known location. This is useful since it may take a while until we get the location lock via either a network or a GPS provider.
% + As usual, we register in onResume(), since that is the method that is called en route to Running state. We use location manager’s requestLocationUpdates() method to register for updates.
% + We unregister in onPause(), which will be called just before the activity goes into the Stopped state.
% + onLocationChanged() is the callback method called by the location manager when it detects that the location has changed.
% + We get the Location object, which contains a lot of useful information about the current location. We create a human-readable string with this info.
% + Once we have the location, we can try to "geocode" the location, a process of converting latitude and longitude to a known address.
% + If we do find known addresses for this location, we print them out.
% + Some other callback methods are required to implement the LocationListener interface. We don’t use them for this example.

+ 留意WhereAmI实现了LocationListener。它是LocationManager用来通知地址变更的接口。
+ 指向LocationManager的私有变量。
+ 指向Geocoder的私有变量。
+ textOut是表示输出结果的TextView。
+ 在当前上下文通过``getSystemService()``获取LocationManager的引用。有关//当前上下文//的有关内容，可见``Application Context``一节。
+ 创建一个Geocoder的实例，将当前上下文传递给它。
+ 还需要一段时间才可以获得新的位置信息。因此LocationManager会缓存着上次得到的地址，可以减少用户的等待。
+ 同前面一样，在进入Running状态之前也就是``onResume`()``时注册到系统服务。在这里，通过``requestLocationUpdates()``订阅Location服务的更新。
+ 在离开Running状态之后也就是``onPause()``时注销。
+ ``onLocationChanged()``是LocationManager负责调用的一个回调方法，在位置信息发生变化时触发。
+ 得到了Location对象。它里面有不少有用的信息，我们格式化一下，使之容易阅读。
+ 得到Location对象，就可以检索"geocode"了，它可以将经纬度转换为实际的地址。
+ 如果得到正确的地址，就输出到textOut。
+ LocationListener接口中还有许多其它的回调方法，这里没有用到这些功能，因此留空。


% ====Manifest file====
====Manifest文件====

% The manifest file for this app is fairly standard. Notice that in order to be able to register as a location listener, we have to hold the appropriate permissions. Keep in mind that although we have GPS and Network as two most commonly used Location Providers, Android is built with extensibility in mind. In the future, we may have other types of providers as well. For that reason, Android breaks down the location permissions into abstract fine location and coarse location permissions.

这个app的Manifest文件也很普通。需要留意的一个地方是，要注册Location的侦听器(Listener)，必先获取相应的权限。GPS和网络是最常用的Location信息源，不过Android也预留了其它信息源的扩展接口——未来也可能有更好更精确的信息源出现。为此，Android将位置信息的权限分成了两级：精确位置(Fine Location)和近似位置(Coarse Location)。

**Example 13.5. AndroidManifest.xml**

{CODE}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.marakana" android:versionCode="1" android:versionName="1.0">
  <application android:icon="@drawable/icon" android:label="@string/app_name">
    <activity android:name=".WhereAmI" android:label="@string/app_name">
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
    </activity>
  </application>
  <uses-sdk android:minSdkVersion="4" />
  <!-- #{1} -->
  <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
  <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />

</manifest>
{/CODE}

% + Declares that this app uses location providers. The location permissions could be android.permission.ACCESS_FINE_LOCATION for a GPS provider or android.permission.ACCESS_COARSE_LOCATION for a wireless network provider.

+ 声明这个app使用了Location信息源。针对GPS，它的权限是``android.permission.ACCESS_FINE_LOCATION``；针对无线网，它的权限是``android.permission.ACCESS_COARSE_LOCATION``。


% At this point, your WhereAmI application is complete. It illustrates how to use LocationManager to get the actual location via a specific location provider and how to convert that location into known addresses via Geocoder. An example of the result is shown in Figure 13.2, “WhereAmI”.

到这里，WhereAmI程序就已经完工了。它演示了通过LocationManager获取位置信息，并通过Geocoder将它转换为地理地址的方法。成品图如下：

**Figure 13.2. WhereAmI**

[images/13-WhereAmI.png]


%==Updating Yamba to Use the Location Service==
==用上Location服务，重构Yamba==

% The WhereAmI application was a small standalone test to make sure we can get location information. Now we’ll incorporate location information into our larger Yamba app.

WhereAmI程序只是用来演示Location服务使用方法的小样例。接下来，我们将Location服务应用到Yamba里面。

% ===Updating Our Preferences===
===更新首选项===

% First, the user may not want to broadcast her location to the world, so we should ask. A good place to ask would be the Preferences. And to do that, this time around, we’ll use a ListPreference property. This is somewhat different from the EditTextPreferences we’ve seen before in Chapter 7, Preferences, File System, Options Menu, and Intents, in that it requires a list of items. In fact, it requires two lists: one to display and one to use for actual values.

在将用户的位置信息广播出去之前，我们需要事先征得用户本人的同意。这不只是个人偏好，更牵涉到个人隐私。首选项就是询问用户本人意愿的一个好地方。在这里，我们可以使用ListPreference。它可以提供一列选项，同时为每个选项对应一个值。

% So we’ll add couple of strings to our strings.xml file and create two new string resources: one to represent names of our location providers in a form friendly to human readers, and the other to represent their values. To do that, we’ll add the following to our strings.xml file:

为此我们在``strings.xml``中添加两列string资源：一列给用户看，表示选项的正文；一列表示每一选项对应的值。修改后的``string.xml``文件如下：

{CODE}
<?xml version="1.0" encoding="utf-8"?>
<resources>
  ...
  <string-array name="providers">
    <item>None, please</item>
    <item>GPS via satellites!</item>
    <item>Mobile Network will do</item>
  </string-array>

  <string-array name="providerValues">
    <item>NONE</item>
    <item>gps</item>
    <item>network</item>
  </string-array>
</resources>
{/CODE}

% Notice that both string arrays have the same number of elements. They basically represent name-value pairs and match each other.

留意这两列string资源是一一对应的，因此其下的条目数相等。

% Now that we have the names and values for our location providers, we can update prefs.xml with that information.

已经有了选项的名与值，接下来修改``prefs.xml``。

**Example 13.6. Updated res/xml/prefs.xml**

{CODE}
<?xml version="1.0" encoding="utf-8"?>
<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
  <EditTextPreference android:title="@string/titleUsername"
    android:summary="@string/summaryUsername" android:key="username"></EditTextPreference>
  <EditTextPreference android:title="@string/titlePassword"
    android:password="true" android:summary="@string/summaryPassword"
    android:key="password"></EditTextPreference>
  <EditTextPreference android:title="@string/titleApiRoot"
    android:summary="@string/summaryApiRoot" android:key="apiRoot"></EditTextPreference>
  <ListPreference android:title="@string/titleProvider"
    android:summary="@string/summaryProvider" android:key="provider"
    android:entryValues="@array/providerValues" android:entries="@array/providers" />
  <!-- #{1} -->
  <ListPreference android:entryValues="@array/intervalValues"
    android:summary="@string/summaryUpdaterInterval" android:title="@string/titleUpdaterInterval"
    android:entries="@array/interval" android:key="interval"></ListPreference>
</PreferenceScreen>
{/CODE}

% + The new ListPreference displaying the names and values of various location providers that we support: GPS, network, and none at all.

+ 新加的ListPreference提供了三个选项：通过GPS、通过网络、不跟踪位置。


% ===Updating the Yamba Application===
===重构YambaApplication===

% Now that we have the preferences supporting settings for a specific location provider the user wishes to use, we have to expose those preferences via our YambaApplication to rest of the app, namely StatusActivity.

已经有了具体的选项条目可供用户选择，我们还需要将这一选项的值暴露在YambaApplication里面，好让应用的其它部分也可以访问它，尤其是StatusActivity。

% To do that, simply add a getter method to YambaApplication.java:

在``YambaApplication.java``里面简单添加一个getter方法即可：

**Example 13.7. YambaApplication.java**

{CODE}
public class YambaApplication extends Application implements
    OnSharedPreferenceChangeListener {
  ...
  public static final String LOCATION_PROVIDER_NONE = "NONE";
  ...
  public String getProvider() {
    return prefs.getString("provider", LOCATION_PROVIDER_NONE);
  }
}
{/CODE}

% Now that we have support for providers in the preferences and in the Yamba app object, we’re ready to update the Status activity.

getter函数准备就绪，接下来重构StatusActivity即可。

% ===Updating the Status Activity===
===重构StatusActivity===

% The Status activity is the main place where we use the location information. Just as in the WhereAmI demo, we’re going to get the Location manger by calling getSystemService() and register for location updates. We’re also going to implement the LocationListener interface, which means adding a number of new callback methods to this activity. When the location does change, we’ll update the location object, and next time around when we update our status online, we’ll have proper location information.

StatusActivity是位置信息。同WhereAmI一样，我们仍调用LocationManager的``getSystemService()``，并注册到Location服务订阅其更新。也同样实现一个LocationListener接口，也就意味着需要在Activity里面添加几个回调方法，好在位置变化时得到新的location对象。到下次更新状态的时候，即可在这里看到我们的位置信息。

**Example 13.8. StatusActivity.java**

{CODE}
package com.marakana.yamba8;

import winterwell.jtwitter.Twitter;
import android.graphics.Color;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.AsyncTask;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

public class StatusActivity extends BaseActivity implements OnClickListener,
    TextWatcher, LocationListener { // #{1}
  private static final String TAG = "StatusActivity";
  private static final long LOCATION_MIN_TIME = 3600000; // One hour
  private static final float LOCATION_MIN_DISTANCE = 1000; // One kilometer
  EditText editText;
  Button updateButton;
  TextView textCount;
  LocationManager locationManager; // #{2}
  Location location;
  String provider;

  /** Called when the activity is first created. */
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.status);

    // Find views
    editText = (EditText) findViewById(R.id.editText);
    updateButton = (Button) findViewById(R.id.buttonUpdate);
    updateButton.setOnClickListener(this);

    textCount = (TextView) findViewById(R.id.textCount);
    textCount.setText(Integer.toString(140));
    textCount.setTextColor(Color.GREEN);
    editText.addTextChangedListener(this);
  }

  @Override
  protected void onResume() {
    super.onResume();

    // Setup location information
    provider = yamba.getProvider(); // #{3}
    if (!YambaApplication.LOCATION_PROVIDER_NONE.equals(provider)) { // #{4}
      locationManager = (LocationManager) getSystemService(LOCATION_SERVICE); // #{5}
    }
    if (locationManager != null) {
      location = locationManager.getLastKnownLocation(provider); // #{6}
      locationManager.requestLocationUpdates(provider, LOCATION_MIN_TIME,
          LOCATION_MIN_DISTANCE, this); // #{7}
    }

  }

  @Override
  protected void onPause() {
    super.onPause();

    if (locationManager != null) {
      locationManager.removeUpdates(this);  // #{8} 
    }
  }

  // Called when button is clicked
  public void onClick(View v) {
    String status = editText.getText().toString();
    new PostToTwitter().execute(status);
    Log.d(TAG, "onClicked");
  }

  // Asynchronously posts to twitter
  class PostToTwitter extends AsyncTask<String, Integer, String> {
    // Called to initiate the background activity
    @Override
    protected String doInBackground(String... statuses) {
      try {
        // Check if we have the location
        if (location != null) { // #{9}
          double latlong[] = {location.getLatitude(), location.getLongitude()};
          yamba.getTwitter().setMyLocation(latlong);
        }
        Twitter.Status status = yamba.getTwitter().updateStatus(statuses[0]);
        return status.text;
      } catch (RuntimeException e) {
        Log.e(TAG, "Failed to connect to twitter service", e);
        return "Failed to post";
      }
    }

    // Called once the background activity has completed
    @Override
    protected void onPostExecute(String result) {
      Toast.makeText(StatusActivity.this, result, Toast.LENGTH_LONG).show();
    }
  }

  // TextWatcher methods
  public void afterTextChanged(Editable statusText) {
    int count = 140 - statusText.length();
    textCount.setText(Integer.toString(count));
    textCount.setTextColor(Color.GREEN);
    if (count < 10)
      textCount.setTextColor(Color.YELLOW);
    if (count < 0)
      textCount.setTextColor(Color.RED);
  }

  public void beforeTextChanged(CharSequence s, int start, int count, int after) {
  }

  public void onTextChanged(CharSequence s, int start, int before, int count) {
  }

  // LocationListener methods
  public void onLocationChanged(Location location) { // #{10}
    this.location = location;
  }

  public void onProviderDisabled(String provider) { // #{11}
    if (this.provider.equals(provider))
      locationManager.removeUpdates(this);
  }

  public void onProviderEnabled(String provider) { // #{12}
    if (this.provider.equals(provider))
      locationManager.requestLocationUpdates(this.provider, LOCATION_MIN_TIME,
          LOCATION_MIN_DISTANCE, this);
  }

  public void onStatusChanged(String provider, int status, Bundle extras) { // #{13}
  }

}
{/CODE}

% + StatusActivity now implements LocationListener, the interface for callbacks from the Location manager.
% + Here we define local variables for the Location manager, Location, and our provider.
% + We get the provider from the Yamba application object, as we explained earlier. And ultimately, the user chooses the provider in the preferences.
% + We check whether the user wants us to provide her location information at all.
% + If we pass that test, we get the location information via getSystemService(). This call is relatively inexpensive even if it happens every time the method runs, because we’re just getting a reference to an already running system service.
% + Get the cached location, if the Location manager has it.
% + Register with the Location manager to receive location updates. Here, we get to specify how often we’d like to get notifications and for what kind of change in location. In our example, we care only about the general vicinity at a city level, we set these values to 1,000 meters (one kilometer) and 3,600,000 milliseconds (one hour). Note that this is just a hint to the system.
% + When this activity is no longer visible, we unregister from the Location manager and no longer receive any updates to save battery.
% + Once the user is about to update her status, we check whether we have a location. If we do, we pack it into required double array and pass it on to setMyLocation() in the Twitter object that Yamba has.
% + Now we implement the methods that Location manager calls. onLocationChanged() is called whenever there’s a change in location and provides us with the actual new Location object.
% + This method is called when the provider is no longer available. We can simply remove any updates so that we don’t waste battery.
% + When the provider we care about is made available, we can request location updates again.
% + This method is called when there’s a change with the provider in general. In this case, we ignore it.

+ 令``StatusActivity``实现``LocationListener``，也就是供LocationManager回调的接口。
+ 定义几个私有变量，分别表示LocationManager、Location对象与位置信息源(Provider)。
+ 获取YambaApplication对象提供的位置信息源(Provider)。使用哪个信息源由用户在首选项中决定。
+ 检查用户是否愿意发布自己的位置信息。
+ 如果检查通过，就使用getSystemService()获取位置信息。这个调用只是获得现有系统服务的引用，因此它的代价并不是很高昂。
+ 如果可以，获取缓存中的位置信息。
+ 注册到LocationManager，订阅位置的更新。在这里，我们可以为位置变化指明一个时间间隔以及位置间距。我们只关心城市级别的位置变化，因此将间距的值定为一千米，时间间隔定为一小时(3,600,000微秒)。留意这只是给系统的一个提示，而非强制。
+ 在用户发布消息时，检查当前是否有位置信息存在。如果有，就把它放在一个double类型的数组里，传给Twitter对象的``setMyLocation()``方法。
+ 实现LocationManager触发的回调方法，``onLocationChanged()``。它在位置变化时触发，以一个新的Location对象作为参数。
+ 这个方法在位置信息源不可用时触发。我们可以在这里注销订阅，以节约电能。
+ 在位置信息源可用时，重新订阅位置信息的更新。
+ 这个方法在位置信息源变化时触发，在此留空。

% At this point our Yamba application supports location updates. User can set preferences to indicate what location provider to use, if any.

到这里，Yamba已经实现了位置更新的功能。用户可以设置首选项，按自己的意愿选择位置信息源，或者关闭这个功能。

% Next we’re going to see another system service: this time the Alarm service, which we’ll use to trigger an Intent service.

接下来看下另一个系统服务：Alarm服务，我们将通过它来触发Intent服务。

