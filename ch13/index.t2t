% 
%

% =System Services=
=系统服务=[ch13]

% Like many modern operating systems, Android comes with a number of system services that are always on, always running, and readily available to developers to tap into. These system services include things like Location service, Sensor service, WiFi service, Alarm service, Telephony service, Bluetooth service, and so on. System services are started at boot time and are guaranteed to be running by the time your application launches.

同其它现代操作系统一样，Android也内置了一系列的系统服务。它们都是随着系统启动，并一直处于运行状态，随时可供开发者访问。比如Location服务、Sensor服务、WiFi服务、Alarm服务、Telephony服务、Bluetooth服务等等。

% In this chapter, we’ll see how we can use some of the system services to further expand the Yamba application. First we’ll take a look at the Sensor service in a small example in order to demonstrate some of the concepts that are common to most of the system services. Then we’ll add support for location information to our status updates via the Location service.

本章介绍几个常见的系统服务，并思考如何将它们应用到Yamba。我们先在一个小例子里引入Sensor服务，借以观察系统服务的一般特性，然后通过Location服务为Yamba添加地理坐标的功能。

% Additionally, we’re going to refactor the Yamba application to take advantage of Intent Service support. This will demonstrate how to use Alarm service and will make our Updater slightly more efficient and simpler.

另外，我们会重构Yamba的代码来获得Intent服务的支持，继而引出Alarm服务，并凭借它们优化Updater的实现。

==Compass Demo==

% To start with system services, we are going to look at a simple, self-contained example of a compass application. This application uses the Sensor service to get updates from the orientation sensor and use its information to rotate a Rose, our custom UI component. The Sensor service is very typical of system services and a relatively easy one to understand.

理解系统服务，我们先从一个简单的样例——指南针(Compass)——开始。它可以通过Sensor服务获得传感器的输出，旋转屏幕上的表盘(Rose)显示方位。Sensor服务是个有代表性的系统服务，也不难懂。

% To build this example, we’ll create an activity that will get the Sensor service and register for updates from a particular sensor. Next, we’ll build the Rose that will rotate on the screen based on the sensor readings.

在例子中，我们先创建一个Activity，由它来访问Sensor服务，订阅来自传感器的输出。然后自定义一个表盘控件(Rose)，使之可以依据传感器端得到的数据旋转一定的角度。

%NOTE: Compass Rose,表盘。翻成“玫瑰”就笑话大了。

% ===Common Steps in Using System Services===
===使用系统服务的一般步骤===

% To get any system service, issue the getSystemService() call. This returns a Manager object representing that system service, which you then use to access the service. Most system services work on some sort of publish/subscribe mechanism. In other words, you generally register your app for notifications from that service and provide your own callbacks methods that the service will invoke when an event happens. To do this in Java, create a Listener that implements an interface so that the service can call the callback methods.

使用系统服务，就调用``getSystemService()``。它返回一个表示系统服务的Manager对象，随后凭它就可以访问系统服务了。系统服务大多都是发布/订阅的接口，使用起来大约就是准备一个回调方法，将你的程序注册到相应的系统服务，然后等它的通知。而在Java中的通行做法是，实现一个内含回调方法的侦听器(Listener)，并把它传递给系统服务。

% Keep in mind that requesting notifications from a system service can be costly in terms of the battery usage. For example, getting a GPS signal or processing sensor updates takes a lot of energy from the device. To preserve the battery, we typically want to be doing the work of processing updates only when the user is looking at the activity itself. In terms of the Activity lifecycle (see the section called “Activity Lifecycle”), this means we want to get the notifications only while in the Running state (see the section called “Running State”).

有一点需要注意，那就是访问系统服务可能会比较费电。比如访问GPS数据或者传感器操作，都会额外消耗设备的电能。为了节约电能，我们可以仅在界面激活时进行传感器操作，使不必要的操作减到最少。用Activity生命周期(参见"Activity生命周期"一节)的说法就是，我们仅在Running状态中响应这些操作。

% To ensure that you request service updates only while in the Running state, register for updates in onResume() and unregister in onPause(). This is because all roads into the Running state go via onResume() and all roads out of it go via onPause(). In certain other situations, you may want to cast the net wider and have the activity be registered between onStart() and onStop(), or even between onCreate() and onDestroy(). In our case, we don’t want to register in onCreate() because it would waste a lot of battery and processing time by making us listen and process sensor updates even when our activity is not in the foreground. You can now see how understanding the Activity lifecycle plays an important role in optimizing usage of system services for the battery consumption.

进入Running状态之前必经``onResume()``，离开Running状态之后必经``onPause()``。因此要保证只在Running状态中使用系统服务，就在``onResume()``中注册到系统服务，并在``onPause()``中注销即可。在某些情景中，我们可能希望将Activity注册在``onStart()``与``onStop()``之间，甚至``onCreate()``与``onDestroy()``之间，好让它在整个生命周期里都在注册中。但在这里，我们并不希望在``onCreate()``中就开始使用系统服务，因为``onCreate()``时，Activity还未显示，在此注册到系统服务只会空耗电能。由此可以看出，对Activity的生命周期有所理解，对省电是肯定有帮助的。

% ===Getting Updates From the Compass===
===获取指南针的更新===

% To code our Compass demo application, we get SensorManager, the class that represents the Sensor system service. We make our main activity implement SensorEventListener so that we can register it (i.e. this) to get updates for a specific sensor. We register and unregister the listener in onResume() and onPause() respectively. To implement the sensor listeners, our activity provides onAccuracyChanged() and onSensorChanged(). The former is a requirement, but we’ll leave it empty because the accuracy of the orientation sensor is not expected to change. The latter call is what’s really of interest to us.

表示Sensor系统服务的类是SensorManager，接下来就是跟它打交道了。在Activity中实现一个SensorEventListener，将它注册到SensorManager中即可订阅特定传感器的更新。为了省电，我们将传感器操作安排在``onResume()``与``onPause()``之间。然后实现侦听器(Listener)，在Activity中提供``onAccuracyChanged()``和``onSensorChanged()``两个方法。前者必须，后者可选。不过我们对传感器的精度(Accuracy)并无兴趣——因为方向传感器(Orientation Sensor)的精度在中间并不会发生变化，我们真正感兴趣的是它的数据。所以在这里我们将前者留空，而提供后者的实现。

% When the orientation sensor changes, the Sensor service calls back our sensor listener via onSensorChanged() and reports the new sensor data. The data always comes back as an array of float values that represent degrees and therefore range from 0 to 359. In the case of orientation sensor, the elements represent the following dimensions, illustrated in Figure 13.1, “Axis”:

在方向传感器状态变化时，Sensor服务会回调``onSensorChanged()``，通知侦听器(Listener)得到了新数据。这些数据都是0~359之间的浮点数组成的数组。方位角(azimuth)与磁偏角(pitch与roll)，构成了下边的坐标，如图13.1：

%NOTE: 磁偏角：磁针指示的方向并不是正南正北，而是微偏西北和东南，这在科学上称为磁偏角。

% Index [0], the azimuth:: The amount of rotation around the Z axis from the vertical position around the back and then around the bottom toward the front. 
% Index [1], the pitch:: The amount of rotation around the X axis from the front to the left and then the around the back toward the right. 
% Index [2], the roll: The amount of rotation around the Y axis from the vertical position to the left and then the around the bottom toward the right.

- 下标[0]，方位角(azimuth)：垂直于Z轴，沿Y轴正方向顺时针旋转的角度。
- 下标[1]，横摇(pitch)：垂直于Y轴，沿Z轴正方向顺时针旋转的角度。
- 下标[2]，纵摇(roll)：垂直于Y轴，沿X轴正方向顺时针旋转的角度。


% For the Compass demo, we are interested only in the first element, i.e., the azimuth. The data returned by each sensor has a different meaning, and you should look up the particulars in the documentation at http://d.android.com/reference/android/hardware/SensorManager.html.

我们的指南针只关心第一个元素，也就是方位角。不同传感器的返回值的含义各有不同，对此需要查询相应的文档 http://d.android.com/reference/android/hardware/SensorManager.html。

**图 13.1. 坐标轴**

[images/13-axis_globe_inverted.png]


% ===Compass Main Activity===
===Compass的主界面===

% The main Compass activity sets the Rose as its only widget on the screen. It also registers with SensorManager to listen to sensor events, and updates the Rose orientation accordingly.

指南针的主界面里只有一个控件，那就是表盘(Rose)。它也将自己注册给SensorManager，监听传感器的事件，调整表盘的角度。

**Example 13.1. Compass.java**

{CODE}
package com.marakana;

import android.app.Activity;
import android.content.res.Configuration;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.Bundle;
import android.util.Log;
import android.view.Window;
import android.view.WindowManager;

// implement SensorListener
public class Compass extends Activity implements SensorEventListener { //#{1}
  SensorManager sensorManager; //#{2}
  Sensor sensor;
  Rose rose;

  /** Called when the activity is first created. */
  @Override
  public void onCreate(Bundle savedInstanceState) { //#{3}
    super.onCreate(savedInstanceState);

    // Set full screen view #{4}
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
        WindowManager.LayoutParams.FLAG_FULLSCREEN);
    requestWindowFeature(Window.FEATURE_NO_TITLE);

    // Create new instance of custom Rose and set it on the screen
    rose = new Rose(this); //#{5}
    setContentView(rose); // #{6}

    // Get sensor and sensor manager
    sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE); // #{7}
    sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION); // #{8}

    Log.d("Compass", "onCreated");
  }

  // Register to listen to sensors
  @Override
  public void onResume() {
    super.onResume();
    sensorManager.registerListener(this, sensor,
        SensorManager.SENSOR_DELAY_NORMAL); // #{9}
  }

  // Unregister the sensor listener
  @Override
  public void onPause() {
    super.onPause();
    sensorManager.unregisterListener(this); // #{10}
  }

  // Ignore accuracy changes
  public void onAccuracyChanged(Sensor sensor, int accuracy) { // #{11}
  }

  // Listen to sensor and provide output
  public void onSensorChanged(SensorEvent event) { // #{12}
    int orientation = (int) event.values[0]; // #{13}
    Log.d("Compass", "Got sensor event: " + event.values[0]);
    rose.setDirection(orientation); // #{14}
  }

  @Override
  public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
  }

}
{/CODE}

% + Since Compass listens to sensor events, it needs to implement the SensorEventListener interface.
% + We define local variable for the sensor, the sensor manager, and the Rose.
% + Because getting access to the sensor is a one-time activity, we do it when our app is created.
% + The window manager flags set the activity into full-screen mode.
% + We create a new instance of the Rose widget, our custom compass rose.
% + In this case, the activity content is the single Rose widget. This is unlike the usual reference to an XML layout resource.
% + We get the sensor manager from the system service.
% + From the sensor manager, we can obtain the actual sensor object that we are interested in.
% + We register to listen to sensor updates in activity’s onResume() method, as described earlier.
% + We unregister from sensor updates in onPause(), the counterpart to onResume().
% + onAccuracyChanged() is implemented because it is required by the SensorEventListener interface. but is left empty as explained earier.
% + onSensorChanged() is called whenever the sensor changes, indicating a rotation of the device in some direction. The particular information about the change is stored in SensorEvent.
% + We are interested in the first element of the array of new values reported.
% + Once we have the new orientation, we update our Rose widget to rotate accordingly.

+ Compass会监听来自传感器的事件，因此需要提供SensorEventListener接口的实现。
+ 定义几个私有变量，分别表示传感器对象(sensor)，SensorManager与表盘(rose)。
+ 初始化sensor是个一次性的操作，因此我们把它放在``onCreate()``中执行。
+ 设置此Activity的状态为全屏。
+ 创建一个Rose控件的实例，这是我们自定义的控件。
+ 这个Activity中唯一的控件就是Rose。这算是个特殊情况，一般而言，在这个地方多是引用XML资源表示的Layout。
+ 获得SensorManager对象。
+ 通过SensorManager对象，选择我们关心的传感器。
+ 同前面所说，在``onResume()``中将自己注册到系统服务，侦听传感器的输出。
+ 对应``onResume()``，在onPause()``中注销系统服务。
+ 依然提供``onAccuracyChanged()``的实现，因为这对SensorEventListener接口来说是必需的。但是留空，前面已有解释。
+ 传感器在状态改变时会回调``onSensorChanged()``，表示设备的方向发生变化。具体的角度信息储存在``SensorEvent``对象中。
+ 我们只关心返回值中的第一个元素。
+ 得到新的方向信息，更新表盘的角度。


{NOTE}
% The way a device reports sensor data can be very erratic, coming at uneven intervals. There are ways to suggest to the system how frequently we’d like the sensor updates, but these are just suggestions and not a guarantee. Also, sensors are not supported by the emulator, so to really test your application, you’ll need a physical device with support for orientation sensor. Most Android phones have that support.

传感器输出的数据流可能是不稳定的，接到数据的时间间隔不可预知。我们可以为传感器提供一个建议的时间间隔，但只是建议，不是强制。另外仿真器没有提供传感器的支持，要测试这个程序就需要一台拥有方向传感器的真机。好在多数Android手机都有这一功能。
{/NOTE}

% ===Custom Rose Widget===
===自定义的表盘控件===

% Rose is our custom UI widget showing the rose of a compass that can be rotated like a real compass. Every UI widget in Android needs to be a subclass of View. But since this is an image, we’ll start from a higher starting point, in this case the ImageView class, which is a View. By subclassing ImageView, our Rose inherits some useful methods to load an image and draw it on the screen.

Rose是我们自定义的UI控件，它可以旋转，表示指南针的表盘。Android中的任何UI控件都是View的子类。Rose的主要部分是一个图片，这一来我们可以让它继承自ImageView类，在较高的层面上实现它，从而可以使用原有的方法实现装载并显示图片。

% With any custom UI widget, one of the most important methods is onDraw(), which draws the widget onto a Canvas that is provided to the method. In case of our Rose, we rotate this canvas around its middle point for the same number of degrees as reported by the orientation sensor. Next, we draw the image onto this rotated sensor as it would have normally be drawn by the super class. The result is a rotated compass rose representing the direction we are pointing to.

自定义一个UI控件，``onDraw()``方法最为重要。它负责控件的绘制与显示。我们需要覆盖父类的逻辑，使图片可以按圆心旋转一定的度数，以表示指南针的方位。

**Example 13.2. Rose.java**

{CODE}
package com.marakana;

import android.content.Context;
import android.graphics.Canvas;
import android.widget.ImageView;

public class Rose extends ImageView { //#{1}
  int direction = 0;

  public Rose(Context context) {
    super(context);

    this.setImageResource(R.drawable.compassrose); // #{2}
  }

  // Called when component is to be drawn
  @Override
  public void onDraw(Canvas canvas) { // #{3}
    int height = this.getHeight();  // #{4}
    int width = this.getWidth();

    canvas.rotate(direction, width / 2, height / 2); // #{5}
    super.onDraw(canvas); // #{6}
  }

  // Called by Compass to update the orientation
  public void setDirection(int direction) { // #{7}
    this.direction = direction;
    this.invalidate(); // request to be redrawn #{8}
  }

}
{/CODE}

% + Our widget has to be a subclass of View, but since our widget is an image, we get more functionality by starting from ImageView.
% + ImageView already knows how to set an image as its content. We just specify to super which image resource to use. Note that compassrose.jpg is in our /res/drawable folder.
% + onDraw() is the method that the layout manager calls to have each widget draw itself. The layout manager passes the Canvas to this method. This method is where you typically do any custom drawing to the canvas.
% + Once we have the canvas, we can figure out its size.
% + We simply rotate the entire canvas for some amount (in degrees) around its mid point.
% + We tell super to draw the image on this rotated canvas. At this point we have our rose drawn at the proper angle.
% + setDirection() is called by the Compass activity to update the direction of the rose based on the values that sensor manager reported.
% + Calling invalidate() on a view marks it for redrawing, which happens later via a call to onDraw().

+ 我们的控件必须是View的子类。它大体就是一张图片，因此可以让它继承自ImageView，得以使用现有的功能。
+ ImageView本身已有设置图片内容的方法，我们需要做的就是为它指明相应的图片。留意，compassrose.jpg文件在/res/drawable之下。
+ ``onDraw()``由Layout Manager负责调用。它会传递过来一个Canvas对象，你可以在这里执行自定义的绘制操作。
+ 已获得Canvas对象，可以计算自身的宽高。
+ 简单地以中点为圆心，旋转整个Canvas(按度数)。
+ 通知super将图片绘制到这个旋转了的Canvas上。到这里表盘就显示出来了。
+ ``setDirection()``由Compass负责调用，它会根据传感器中获得的数据调整Rose的方向。
+ 对View调用``invalidate()``，就可以要求它重绘。也就是在稍后调用``onDraw()``。


% At this point, your compass application is working. The compass rose should be pointing north, more or less, when the device is held upright as usual. Keep in mind that you should run this application on a physical device as the emulator doesn’t support.

到这里，指南针程序已经可用了。在设备横放时，表盘应大致指向北方。仿真器没有传感器的支持，因此这个程序只能在真机上运行。


% ==Location Service==
==Location服务==

% Now that you have seen how the sensor manager works, we can look at the Location API, another system service provided by Android. Just like sensors, the Location API is supported via the Location manager. And just like sensors, we get the Location manager via a getSystemService() call.

前面已对SensorManager的工作方式有所了解，接下来看下Location服务的API。同Sensor服务类似，Location服务是通过LocationManager进行管理，而且也是通过getSystemService()获取它的引用。

% Once we have access to the Location service, we need to register a Location listener with it so the service can call back when there’s a change in location. Again, we’ll do this by implementing a Location listener interface.

使用Location服务，我们需要传递给它一个侦听器(Listener)，这一来在位置改变的时候可以作出响应。同前面相似，我们在这里实现一个LocationListener接口。

% If you recall from the section called “Common Steps in Using System Services”, processing GPS and other location updates can be very taxing for the battery. To minimize the battery consumption, we want to listen to location updates only while in the Running state. To do that, we’ll register for the updates in onResume() and unregister in onPause(), taking the advantage of the Activity lifecycle.

//"使用系统服务的一般步骤"//一节曾提到，使用GPS服务或者其它位置操作都是非常费电的。为尽量地节约电能，我们只在Running状态中使用Location服务。因此利用Activity生命周期的设定，将它限制在``onResume()``与``onPause()``之间。

===Where Am I? Demo===

% This example illustrates how to use location-based services in Android. First, we use LocationManager to figure out our current location based on the resources in the environment available to the device, such as GPS or a wireless network. Secondly, we use Geocoder to convert this location to an address.

使用这个例子展示Android中位置服务的用法。首先通过LocationManager利用可用的信息源(GPS或者无线网)获取当前的位置信息，然后使用Geocoder将它转换为人类可读的地理地址。

====The Layout====

% The layout for this example is trivial. Our resource file provides a TextView widget for the title and another TextView widget for the output. Since the output could be longer than the screen size, we wrap the output in a ScrollView widget.

本例的Layout不是我们关注的重点。里面只有一个表示标题的TextView控件，和一个表示输出的TextView控件。其中输出可能会比较长，因此把它包在一个ScrollView里。

**Example 13.3. res/layout/main.xml**

{CODE}
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:layout_height="fill_parent" android:layout_width="fill_parent"
  android:background="#fff" android:orientation="vertical">
  <!-- #{1} -->
  <TextView android:layout_width="wrap_content"
    android:layout_height="wrap_content" android:layout_gravity="center"
    android:textColor="#333" android:textSize="30dp" android:text="@string/title"></TextView>
  <!-- #{2} -->
  <ScrollView android:layout_height="fill_parent"
    android:layout_width="fill_parent">
    <!-- #{3} -->
    <TextView android:textColor="#333" android:layout_gravity="center"
      android:layout_height="fill_parent" android:layout_width="fill_parent"
      android:gravity="center" android:textSize="25dp" android:text="Waiting..."
      android:id="@+id/textOut"></TextView>
  </ScrollView>
</LinearLayout>
{/CODE}

% + The title for our application.
% + A ScrollView to enable scrolling if the output grows beyond the size of the screen.
% + A TextView to represent the output. It will be programmatically set from the WhereAmI activity.

+ 程序的标题。
+ 输出可能会比较长，甚至超过屏幕的尺寸。因此，通过ScrollView为它加一个滚动条。
+ 表示输出的TextView，``WhereAmI``界面中唯一的动态部分。


% ====The Activity for our Location Listener====
====作为LocationListener的Activity====

% This is our main activity, which sets up the screen, connects to LocationManager, and uses the Geocoder to figure out our address. The LocationManager uses location providers, such as GPS or Network, to figure out our current location. The location is expressed as latitude and longitude values. The Geocoder searches an online database for known addresses in the vicinity of the location provided. It may come up with multiple results, some more specific than others.

这就是我们唯一的Activity。我们将在这里初始化界面，连接到LocationManager，然后使用Geocoder检索我们的地理地址。LocationManager可以通过不同的Location信息源(比如GPS或者网络)来获得我们的当前位置，以经纬度的格式返回。Geocoder以此检索在线的位置数据库，即可获得当前位置的地理地址。检索的结果可能有多个，精度不一。

**Example 13.4. WhereAmI.java**

{CODE}
package com.marakana;

import java.io.IOException;
import java.util.List;

import android.app.Activity;
import android.location.Address;
import android.location.Geocoder;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class WhereAmI extends Activity implements LocationListener { // #{1}
  LocationManager locationManager; // #{2}
  Geocoder geocoder; // #{3}
  TextView textOut; // #{4}

  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    textOut = (TextView) findViewById(R.id.textOut);

    locationManager = (LocationManager) getSystemService(LOCATION_SERVICE); // #{5}
    geocoder = new Geocoder(this); // #{6}

    // Initialize with the last known location
    Location lastLocation = locationManager
        .getLastKnownLocation(LocationManager.GPS_PROVIDER); // #{7}
    if (lastLocation != null)
      onLocationChanged(lastLocation);
  }

  @Override
  protected void onResume() { // #{8}
    super.onRestart();
    locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 1000,
        10, this);
  }

  @Override
  protected void onPause() { // #{9}
    super.onPause();
    locationManager.removeUpdates(this);
  }

  // Called when location has changed
  public void onLocationChanged(Location location) { // #{10}
    String text = String.format(
        "Lat:\t %f\nLong:\t %f\nAlt:\t %f\nBearing:\t %f", location
            .getLatitude(), location.getLongitude(), location.getAltitude(),
        location.getBearing()); // #{11}
    textOut.setText(text);

    // Perform geocoding for this location
    try {
      List<Address> addresses = geocoder.getFromLocation(
          location.getLatitude(), location.getLongitude(), 10); // #{12}
      for (Address address : addresses) {
        textOut.append("\n" + address.getAddressLine(0)); // #{13}
      }
    } catch (IOException e) {
      Log.e("WhereAmI", "Couldn't get Geocoder data", e);
    }
  }

  // Methods required by LocationListener 
  public void onProviderDisabled(String provider) {
  }

  public void onProviderEnabled(String provider) {
  }

  public void onStatusChanged(String provider, int status, Bundle extras) {
  }

}
{/CODE}

% + Notice that WhereAmI implements LocationListener. This is the interface that LocationManager uses to notify us of changes to location.
% + Local reference to LocationManager.
% + Local reference to Geocoder.
% + textOut is the text view to which we print our output to for the user to see.
% + We get the local reference to LocationManager by asking the context to get the location manager system service. For a reference on context, see the section called “Application Context”.
% + We create a new instance of Geocoder and pass the current context to it.
% + The Location manager memorizes its last known location. This is useful since it may take a while until we get the location lock via either a network or a GPS provider.
% + As usual, we register in onResume(), since that is the method that is called en route to Running state. We use location manager’s requestLocationUpdates() method to register for updates.
% + We unregister in onPause(), which will be called just before the activity goes into the Stopped state.
% + onLocationChanged() is the callback method called by the location manager when it detects that the location has changed.
% + We get the Location object, which contains a lot of useful information about the current location. We create a human-readable string with this info.
% + Once we have the location, we can try to "geocode" the location, a process of converting latitude and longitude to a known address.
% + If we do find known addresses for this location, we print them out.
% + Some other callback methods are required to implement the LocationListener interface. We don’t use them for this example.

+ 留意WhereAmI实现了LocationListener。它是LocationManager用来通知地址变更的接口。
+ 指向LocationManager的私有变量。
+ 指向Geocoder的私有变量。
+ textOut是表示输出结果的TextView。
+ 在当前上下文通过``getSystemService()``获取LocationManager的引用。有关//当前上下文//的有关内容，可见``Application Context``一节。
+ 创建一个Geocoder的实例，将当前上下文传递给它。
+ 还需要一段时间才可以获得新的位置信息。因此LocationManager会缓存着上次得到的地址，可以减少用户的等待。
+ 同前面一样，在进入Running状态之前也就是``onResume`()``时注册到系统服务。在这里，通过``requestLocationUpdates()``订阅Location服务的更新。
+ 在离开Running状态之后也就是``onPause()``时注销。
+ ``onLocationChanged()``是LocationManager负责调用的一个回调方法，在位置信息发生变化时触发。
+ 得到了Location对象。它里面有不少有用的信息，我们格式化一下，使之容易阅读。
+ 只要得到Location对象，就可以检索"geocode"了，它可以将经纬度转换为实际的地址。
+ 如果得到正确的地址，就输出到textOut。
+ LocationListener接口中还有许多其它的回调方法，这里没有用到这些功能，因此留空。


% ====Manifest file====
====Manifest文件====

% The manifest file for this app is fairly standard. Notice that in order to be able to register as a location listener, we have to hold the appropriate permissions. Keep in mind that although we have GPS and Network as two most commonly used Location Providers, Android is built with extensibility in mind. In the future, we may have other types of providers as well. For that reason, Android breaks down the location permissions into abstract fine location and coarse location permissions.

这个app的Manifest文件也很普通。需要留意的一个地方是，要注册Location的侦听器(Listener)，必先获取相应的权限。GPS和网络是最常用的Location信息源，不过Android也预留了其它信息源的扩展接口——未来也可能有更好更精确的信息源出现。为此，Android将位置信息的权限分成了两级：精确位置(Fine Location)和近似位置(Coarse Location)。

**Example 13.5. AndroidManifest.xml**
{CODE}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.marakana" android:versionCode="1" android:versionName="1.0">
  <application android:icon="@drawable/icon" android:label="@string/app_name">
    <activity android:name=".WhereAmI" android:label="@string/app_name">
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
    </activity>
  </application>
  <uses-sdk android:minSdkVersion="4" />
  <!-- #{1} -->
  <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
  <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />

</manifest>
{/CODE}

% + Declares that this app uses location providers. The location permissions could be android.permission.ACCESS_FINE_LOCATION for a GPS provider or android.permission.ACCESS_COARSE_LOCATION for a wireless network provider.

+ 声明这个app使用了Location信息源。针对GPS，它的权限是``android.permission.ACCESS_FINE_LOCATION``；针对无线网，它的权限是``android.permission.ACCESS_COARSE_LOCATION``。


% At this point, your WhereAmI application is complete. It illustrates how to use LocationManager to get the actual location via a specific location provider and how to convert that location into known addresses via Geocoder. An example of the result is shown in Figure 13.2, “WhereAmI”.

到这里，WhereAmI程序就已经完工了。它演示了通过LocationManager获取位置信息，并通过Geocoder将它转换为地理地址的方法。成品图如下：

**图 13.2. WhereAmI**

[images/13-WhereAmI.png]


%==Updating Yamba to Use the Location Service==
==用上Location服务，重构Yamba==

% The WhereAmI application was a small standalone test to make sure we can get location information. Now we’ll incorporate location information into our larger Yamba app.

WhereAmI程序只是用来演示Location服务使用方法的小样例。接下来，我们将Location服务应用到Yamba里面。

% ===Updating Our Preferences===
===更新首选项===

% First, the user may not want to broadcast her location to the world, so we should ask. A good place to ask would be the Preferences. And to do that, this time around, we’ll use a ListPreference property. This is somewhat different from the EditTextPreferences we’ve seen before in Chapter 7, Preferences, File System, Options Menu, and Intents, in that it requires a list of items. In fact, it requires two lists: one to display and one to use for actual values.

在将用户的位置信息广播出去之前，我们需要事先征得用户本人的同意。这不只是个人偏好，更牵涉到个人隐私。首选项就是询问用户本人意愿的一个好地方。在这里，我们可以使用ListPreference。它可以提供一列选项，同时为每个选项对应一个值。

% So we’ll add couple of strings to our strings.xml file and create two new string resources: one to represent names of our location providers in a form friendly to human readers, and the other to represent their values. To do that, we’ll add the following to our strings.xml file:

为此我们在``strings.xml``中添加两列string资源：一列给用户看，表示选项的正文；一列表示每一选项对应的值。修改后的``string.xml``文件如下：

{CODE}
<?xml version="1.0" encoding="utf-8"?>
<resources>
  ...
  <string-array name="providers">
    <item>None, please</item>
    <item>GPS via satellites!</item>
    <item>Mobile Network will do</item>
  </string-array>

  <string-array name="providerValues">
    <item>NONE</item>
    <item>gps</item>
    <item>network</item>
  </string-array>
</resources>
{/CODE}

% Notice that both string arrays have the same number of elements. They basically represent name-value pairs and match each other.

留意这两列string资源是一一对应的，因此其下的条目数相等。

% Now that we have the names and values for our location providers, we can update prefs.xml with that information.

已经有了选项的名与值，接下来修改``prefs.xml``。

**Example 13.6. Updated res/xml/prefs.xml**

{CODE}
<?xml version="1.0" encoding="utf-8"?>
<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
  <EditTextPreference android:title="@string/titleUsername"
    android:summary="@string/summaryUsername" android:key="username"></EditTextPreference>
  <EditTextPreference android:title="@string/titlePassword"
    android:password="true" android:summary="@string/summaryPassword"
    android:key="password"></EditTextPreference>
  <EditTextPreference android:title="@string/titleApiRoot"
    android:summary="@string/summaryApiRoot" android:key="apiRoot"></EditTextPreference>
  <ListPreference android:title="@string/titleProvider"
    android:summary="@string/summaryProvider" android:key="provider"
    android:entryValues="@array/providerValues" android:entries="@array/providers" />
  <!-- #{1} -->
  <ListPreference android:entryValues="@array/intervalValues"
    android:summary="@string/summaryUpdaterInterval" android:title="@string/titleUpdaterInterval"
    android:entries="@array/interval" android:key="interval"></ListPreference>
</PreferenceScreen>
{/CODE}

% + The new ListPreference displaying the names and values of various location providers that we support: GPS, network, and none at all.

+ 新加的ListPreference提供了三个选项：通过GPS、通过网络、不跟踪位置。


% ===Updating the Yamba Application===
===重构YambaApplication===

% Now that we have the preferences supporting settings for a specific location provider the user wishes to use, we have to expose those preferences via our YambaApplication to rest of the app, namely StatusActivity.

已经有了具体的选项条目可供用户选择，我们还需要将这一选项的值暴露在YambaApplication里面，好让应用的其它部分也可以访问它，尤其是StatusActivity。

% To do that, simply add a getter method to YambaApplication.java:

在``YambaApplication.java``里面简单添加一个getter方法即可：

**Example 13.7. YambaApplication.java**

{CODE}
public class YambaApplication extends Application implements
    OnSharedPreferenceChangeListener {
  ...
  public static final String LOCATION_PROVIDER_NONE = "NONE";
  ...
  public String getProvider() {
    return prefs.getString("provider", LOCATION_PROVIDER_NONE);
  }
}
{/CODE}

% Now that we have support for providers in the preferences and in the Yamba app object, we’re ready to update the Status activity.

getter函数准备就绪，接下来重构StatusActivity即可。

% ===Updating the Status Activity===
===重构StatusActivity===

% The Status activity is the main place where we use the location information. Just as in the WhereAmI demo, we’re going to get the Location manger by calling getSystemService() and register for location updates. We’re also going to implement the LocationListener interface, which means adding a number of new callback methods to this activity. When the location does change, we’ll update the location object, and next time around when we update our status online, we’ll have proper location information.

StatusActivity是位置信息。同WhereAmI一样，我们仍调用LocationManager的``getSystemService()``，并注册到Location服务订阅其更新。也同样实现一个LocationListener接口，也就意味着需要在Activity里面添加几个回调方法，好在位置变化时得到新的location对象。到下次更新状态的时候，即可在这里看到我们的位置信息。

**Example 13.8. StatusActivity.java**

{CODE}
package com.marakana.yamba8;

import winterwell.jtwitter.Twitter;
import android.graphics.Color;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.AsyncTask;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

public class StatusActivity extends BaseActivity implements OnClickListener,
    TextWatcher, LocationListener { // #{1}
  private static final String TAG = "StatusActivity";
  private static final long LOCATION_MIN_TIME = 3600000; // One hour
  private static final float LOCATION_MIN_DISTANCE = 1000; // One kilometer
  EditText editText;
  Button updateButton;
  TextView textCount;
  LocationManager locationManager; // #{2}
  Location location;
  String provider;

  /** Called when the activity is first created. */
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.status);

    // Find views
    editText = (EditText) findViewById(R.id.editText);
    updateButton = (Button) findViewById(R.id.buttonUpdate);
    updateButton.setOnClickListener(this);

    textCount = (TextView) findViewById(R.id.textCount);
    textCount.setText(Integer.toString(140));
    textCount.setTextColor(Color.GREEN);
    editText.addTextChangedListener(this);
  }

  @Override
  protected void onResume() {
    super.onResume();

    // Setup location information
    provider = yamba.getProvider(); // #{3}
    if (!YambaApplication.LOCATION_PROVIDER_NONE.equals(provider)) { // #{4}
      locationManager = (LocationManager) getSystemService(LOCATION_SERVICE); // #{5}
    }
    if (locationManager != null) {
      location = locationManager.getLastKnownLocation(provider); // #{6}
      locationManager.requestLocationUpdates(provider, LOCATION_MIN_TIME,
          LOCATION_MIN_DISTANCE, this); // #{7}
    }

  }

  @Override
  protected void onPause() {
    super.onPause();

    if (locationManager != null) {
      locationManager.removeUpdates(this);  // #{8} 
    }
  }

  // Called when button is clicked
  public void onClick(View v) {
    String status = editText.getText().toString();
    new PostToTwitter().execute(status);
    Log.d(TAG, "onClicked");
  }

  // Asynchronously posts to twitter
  class PostToTwitter extends AsyncTask<String, Integer, String> {
    // Called to initiate the background activity
    @Override
    protected String doInBackground(String... statuses) {
      try {
        // Check if we have the location
        if (location != null) { // #{9}
          double latlong[] = {location.getLatitude(), location.getLongitude()};
          yamba.getTwitter().setMyLocation(latlong);
        }
        Twitter.Status status = yamba.getTwitter().updateStatus(statuses[0]);
        return status.text;
      } catch (RuntimeException e) {
        Log.e(TAG, "Failed to connect to twitter service", e);
        return "Failed to post";
      }
    }

    // Called once the background activity has completed
    @Override
    protected void onPostExecute(String result) {
      Toast.makeText(StatusActivity.this, result, Toast.LENGTH_LONG).show();
    }
  }

  // TextWatcher methods
  public void afterTextChanged(Editable statusText) {
    int count = 140 - statusText.length();
    textCount.setText(Integer.toString(count));
    textCount.setTextColor(Color.GREEN);
    if (count < 10)
      textCount.setTextColor(Color.YELLOW);
    if (count < 0)
      textCount.setTextColor(Color.RED);
  }

  public void beforeTextChanged(CharSequence s, int start, int count, int after) {
  }

  public void onTextChanged(CharSequence s, int start, int before, int count) {
  }

  // LocationListener methods
  public void onLocationChanged(Location location) { // #{10}
    this.location = location;
  }

  public void onProviderDisabled(String provider) { // #{11}
    if (this.provider.equals(provider))
      locationManager.removeUpdates(this);
  }

  public void onProviderEnabled(String provider) { // #{12}
    if (this.provider.equals(provider))
      locationManager.requestLocationUpdates(this.provider, LOCATION_MIN_TIME,
          LOCATION_MIN_DISTANCE, this);
  }

  public void onStatusChanged(String provider, int status, Bundle extras) { // #{13}
  }

}
{/CODE}

% + StatusActivity now implements LocationListener, the interface for callbacks from the Location manager.
% + Here we define local variables for the Location manager, Location, and our provider.
% + We get the provider from the Yamba application object, as we explained earlier. And ultimately, the user chooses the provider in the preferences.
% + We check whether the user wants us to provide her location information at all.
% + If we pass that test, we get the location information via getSystemService(). This call is relatively inexpensive even if it happens every time the method runs, because we’re just getting a reference to an already running system service.
% + Get the cached location, if the Location manager has it.
% + Register with the Location manager to receive location updates. Here, we get to specify how often we’d like to get notifications and for what kind of change in location. In our example, we care only about the general vicinity at a city level, we set these values to 1,000 meters (one kilometer) and 3,600,000 milliseconds (one hour). Note that this is just a hint to the system.
% + When this activity is no longer visible, we unregister from the Location manager and no longer receive any updates to save battery.
% + Once the user is about to update her status, we check whether we have a location. If we do, we pack it into required double array and pass it on to setMyLocation() in the Twitter object that Yamba has.
% + Now we implement the methods that Location manager calls. onLocationChanged() is called whenever there’s a change in location and provides us with the actual new Location object.
% + This method is called when the provider is no longer available. We can simply remove any updates so that we don’t waste battery.
% + When the provider we care about is made available, we can request location updates again.
% + This method is called when there’s a change with the provider in general. In this case, we ignore it.

+ 令``StatusActivity``实现``LocationListener``，也就是供LocationManager回调的接口。
+ 定义几个私有变量，分别表示LocationManager、Location对象与位置信息源(Provider)。
+ 获取YambaApplication对象提供的位置信息源(Provider)。使用哪个信息源由用户在首选项中决定。
+ 检查用户是否愿意发布自己的位置信息。
+ 如果检查通过，就使用getSystemService()获取位置信息。这个调用只是获得现有系统服务的引用，因此它的代价并不是很高昂。
+ 如果可以，获取缓存中的位置信息。
+ 注册到LocationManager，订阅位置的更新。在这里，我们可以为位置变化指明一个时间间隔以及位置间距。我们只关心城市级别的位置变化，因此将间距的值定为一千米，时间间隔定为一小时(3,600,000微秒)。留意这只是给系统的一个提示，而非强制。
+ 在用户发布消息时，检查当前是否有位置信息存在。如果有，就把它放在一个double类型的数组里，传给Twitter对象的``setMyLocation()``方法。
+ 实现LocationManager触发的回调方法，``onLocationChanged()``。它在位置变化时触发，以一个新的Location对象作为参数。
+ 这个方法在位置信息源不可用时触发。我们可以在这里注销订阅，以节约电能。
+ 在位置信息源可用时，重新订阅位置信息的更新。
+ 这个方法在位置信息源变化时触发，在此留空。

% At this point our Yamba application supports location updates. User can set preferences to indicate what location provider to use, if any.

到这里，Yamba已经实现了位置更新的功能。用户可以设置首选项，按自己的意愿选择位置信息源，也可以关闭这个功能。

% Next we’re going to see another system service: this time the Alarm service, which we’ll use to trigger an Intent service.

接下来看下另一个系统服务：Alarm服务，我们将通过它来触发IntentService。


==IntentService==

% Now that we understand how system services work, we can use another service concept to substantially simplify our Updater service. If you recall, our Updater service is an always-on, always-running service that periodically goes to the cloud and pulls down the latest timeline updates. Since by default a service runs in the same thread as the User Interface (i.e., runs on the UI thread), we had to create a separate thread called Updater within the Updater service that is responsible for the actual network connection. We then started this thread in the service’s onCreate() and onStartCommand() methods. We ran it forever until onDestroy() got called. However, our Updater thread would sleep between the updates for some amount of time. All this worked well and we explained it all in Chapter 8, Services. But there’s a simpler way to accomplish this task.

我们已对系统服务的工作方式有所了解，接下来可以利用系统服务的有关特性，简化UpdaterService的实现。回忆下前面的内容：UpdaterService会一直运行，定期从服务端抓取Timeline的更新。由于Service默认与UI在同一个线程(或者说，都在UI线程中执行)中执行，为避免网络操作造成界面的响应不灵，我们需要新建一个Updater线程，并将UpdaterService放在里面独立执行。然后在Service的``onCreate()``与``onStartCommand()``中让线程开始，并一直执行下去，直到``onDestroy()``为止。另外，Updater会在两次更新之间休眠一段时间。这是第八章所讲的内容，但在这里，我们将介绍更简便的实现方法。

% An IntentService is a subclass of Service and is also activated by a startService() intent. It differs from a regular service by running on its own worker thread, so it doesn’t block our precious UI thread. Also, once it’s done, it’s done. This means it runs only once, but we will use an Alarm later to run it periodically. Any call to the intent’s startService() will recreate it.

IntentService是Service的一个子类，也是通过``startService()``发出的intent激活。与一般Service的不同在于，它默认在一个独立的工人线程(Worker Thread)中执行，因此不会阻塞UI线程。另一点，它一旦执行完毕，生命周期也就结束了。不过只要接到``startService()``发出的Intent，它就会新建另一个生命周期，从而实现重新执行。在此，我们可以利用Alarm实现定期执行。

% Unlike a regular service, we don’t override onCreate(), onStartCommand(), onDestroy(), and onBind(), but rather a new onHandleIntent() method. This method is where we want to put our code that goes online and handles the network updates. Also, unlike a regular Service, an IntentService has a default constructor that needs to be provided.

同一般的Service不同，我们不需要覆盖``onCreate()``、``onStartCommand()``、``onDestroy()``及``onBind()``，而是覆盖一个``onHandleIntent()``方法。网络操作的相关代码就放在这里。另外IntentService要求我们实现一个构造函数，这也是与一般Service不同的地方。

% In short, instead of creating a separate thread and delaying network updates in regular Service, we can simplify our code by using an IntentService to run status updates on its worker thread. Now we just need something to periodically wake up our IntentService so it knows it needs to handle the updating job. For that, we’ll use the Alarm manager, another system service.

简言之，除了创建一个独立线程使用普通的Service之外，我们可以使用IntentService在它自己的工人线程中实现同样的功能，而且更简单。到现在剩下的只是定期唤醒它，这就引出了AlarmManager，另一个系统服务。

% The key to Intent Services is the onHandleIntent() method, a block of code that will run on a separate thread.

以上的原理就在于，IntentService的``onHandleIntent()``会在独立的线程中执行。

**Example 13.9. UpdaterService.java based on IntentService**
{CODE}
package com.marakana.yamba8;

import android.app.IntentService;
import android.content.Intent;
import android.util.Log;

public class UpdaterService1 extends IntentService { // #{1}
  private static final String TAG = "UpdaterService";

  public static final String NEW_STATUS_INTENT = "com.marakana.yamba.NEW_STATUS";
  public static final String NEW_STATUS_EXTRA_COUNT = "NEW_STATUS_EXTRA_COUNT";
  public static final String RECEIVE_TIMELINE_NOTIFICATIONS = "com.marakana.yamba.RECEIVE_TIMELINE_NOTIFICATIONS";

  public UpdaterService1() { // #{2}
    super(TAG);

    Log.d(TAG, "UpdaterService constructed");
  }

  @Override
  protected void onHandleIntent(Intent inIntent) { // #{3}
    Intent intent;
    Log.d(TAG, "onHandleIntent'ing");
    YambaApplication yamba = (YambaApplication) getApplication();
    int newUpdates = yamba.fetchStatusUpdates();
    if (newUpdates > 0) { // #{4}
      Log.d(TAG, "We have a new status");
      intent = new Intent(NEW_STATUS_INTENT);
      intent.putExtra(NEW_STATUS_EXTRA_COUNT, newUpdates);
      sendBroadcast(intent, RECEIVE_TIMELINE_NOTIFICATIONS);
    }
  }
}
{/CODE}

% + We now subclass IntentService instead of its parent Service.
% + A default constructor is needed. This a good place to give your service a name, which can be relevant for example in TraceView, to be able to identify various threads.
% + This is the key method. The work inside of it takes place on a separate worker thread and doesn’t interfere with the main UI thread.
% + The rest of the code in this section broadcasts the change as described in the section called “Broadcasting Intents”.

+ 继承自IntentService，而非Service。
+ 这里需要一个构造函数。在这里，可以给Service一个命名，以便于在观测工具(比如TraceView)中，辨认相应的线程。
+ 这是关键的方法。其中的代码会在独立的工人线程中执行，因此不会影响到主UI线程的响应。
+ 下面将所做的变化广播出去，具体可见 //第十一章// 中的 //"广播 Intent"// 一节。

%TALK: "Broadcasting Intent"需改为中文。

% At this point, our service is updated. An easy way to test it would be to change the Start/Stop Service menu item to a Refresh button. To do that, update your menu.xml file to have this new item, and change its handling in our BaseActivity class.

这样，我们重构了原先的Service。要测试它，不妨先把Start/Stop Service的按钮改为Refresh按钮。为此需要修改``menu.xml``添加这个新条目，然后在BaseActivity类中修改它的处理方法。

**Example 13.10. res/xml/menu.xml**
{CODE}
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
  ...
  <item android:title="@string/titleRefresh" android:id="@+id/itemRefresh"
    android:icon="@android:drawable/ic_menu_rotate"></item>
</menu>
{/CODE}

% I’ve replaced itemToggle with itemRefresh so that the names make more sense. We must also add the appropriate string to the strings.xml file.

把``itemToggle``改为``itemRefresh``，这样更合适一些。同时必须更新``string.xml``中对应的条目。

% Now, we need to update our BaseActivity.java file to handle this new Refresh button. To do that, we change the appropriate case statement in onOptionsItemSelected(). Additionally, we can now remove onMenuOpened() altogether, since we no longer need to change the state of that toggle button—it doesn’t exist any more.

接下来修改``BaseActivity.java``文件，添加这个按钮的处理方法，也就是修改``onOptionsItemSelected()``中对应的case语句。同时``onMenuOpened()``已经没有用处了，删掉即可。

**Example 13.11. BaseActivity.java with support for Refresh button**
{CODE}
public class BaseActivity extends Activity {
  ...
  @Override
  public boolean onOptionsItemSelected(MenuItem item) {

    switch (item.getItemId()) {
    ...
    case R.id.itemRefresh:
      startService(new Intent(this, UpdaterService.class)); // #{1}
      break;
    ...
    }
    return true;
  }
  ...
}
{/CODE}

% + We simply fire off an intent to start our Updater service.

+ 简单地发送一个Intent，启动UpdaterService。

% So our options menu now has a Refresh button that will start a service and have it update the status data in the background. We can use this button to test whether this feature works well.

这样选项菜单就多了一个Refresh按钮，可以启动一个Service让它在后台更新消息。测试的话，点击这个按钮就好。

% Another way to accomplish the same same functionality would have been to use an AsyncTask. In fact, AsyncTask would probably have been slightly more appropriate in this case from a design point of view, to keep all the functionality at the UI level, but we’ve already discussed it in the section called “Threading in Android”. In this case, we wanted to demonstrate quickly how an IntentService is started, and as you can see, it works just like any other service.

实现同样的功能还有一个选择，那就是AsyncTask。在设计角度讲，使用AsyncTask甚至可能比IntentService更加合适——它使得这些功能在UI层面即可全部实现，这在 //第六章// 中的 //Android的线程机制// 已有提及。不过在这里，我们更希望了解IntentService的工作方式，通过演示不难看出，它的功能并不弱于普通的Service。

% Next we want to have our Updater service triggered periodically. To do that, we’ll use the Alarm manager.

接下来需要做的，就是定时触发UpdaterService。因此引入AlarmManager。

===Alarms===

% The previous reincarnation of our Updater service had a regular service that was always running in a loop, where it pulled network updates, then slept for some amount of time and and looped again. With IntentService, we turned the process around. Our Updater service now runs only once when fired up by the startService() intent. So, now we need a way to have something fire these intents every so often.

在重构之前，UpdaterService是一个普通的Service，一直处于运行状态，每执行一次网络操作就休眠一段时间然后循环；重构之后改用了IntentService，每收到startService()发出的Intent只会执行一次，随即结束。因此，我们需要一个办法定期发送Intent来启动它。

% Android comes with yet another system service just for that. The Alarm service, represented by the AlarmManager class, lets you schedule certain things to happen at certain times. The time can be recurring, so that makes it easy to have our service be started every so often. And the event that happens is an intent, or more precisely a PendingIntent.

这就引出了Android的另一个系统服务——Alarm服务。它由AlarmManager控制，允许你在一定时间之后触发某操作。它可以是一次结束，也可以是周期重复，因此可以利用它来定时启动我们的Service。Alarm服务通知的事件都是以Intent形式发出，或者更准确一点，以PendingIntent的形式。

%NOTE: PendingIntent在第四五章似乎提到过，留意。

====PendingIntent====

% A PendingIntent is a combination of an intent with an action to be executed on it. This is typically used for future intents that you are passing to someone else. Create a Pending Intent via one of the static methods in the PendingIntent class. Since there are only handful of ways to send an intent, there are only a handful of static methods to create Pending Intents along with their actions. If you recall, you typically use an intent to start an activity via startActivity(), start a service via startService(), or send a broadcast via sendBroadcast(). So to create a Pending intent that will execute startService() with our intent in the future, we call the getService() static method.

PendingIntent是Intent与某操作的组合。一般是把它交给他人，由他人负责发送，并在未来执行那项操作。发送Intent的方法并不多，创建PendingIntent的方法也是如此——只有PendingIntent类中的几个静态方法，在创建的同时也将相关的操作绑定了。回忆一下，同为发送Intent，启动Activity靠startActivity()，启动Service靠startService()，发送广播靠sendBroadcast()，而创建对应于startService()操作的PendingIntent，靠它的静态方法getService()。

% Now that we know how to leave an intent for someone to execute later and how to tell an Alarm service to do that over and over periodically, we need to choose where to implement this feature. One good place is our existing Boot Receiver. But before we do that, we’ll add another preference option to our preferences

已经知道了如何交代他人发送Intent，也知道了如何通过Alarm服务实现定期执行。接下来就是找个合适的地方，将两者结合起来。而这个地方就是BootReceiver。

在编写相关的代码之前，我们先增加一条首选项：

% ===Adding Interval to Preferences===
===添加Interval选项===

**Example 13.12. strings.xml with arrays for interval options**
{CODE}
<?xml version="1.0" encoding="utf-8"?>
<resources>
  ...

  <!-- #{1} -->
  <string-array name="interval">
    <item>Never</item>
    <item>Fifteen minutes</item>
    <item>Half hour</item>
    <item>An hour</item>
    <item>Half day</item>
    <item>Day</item>
  </string-array>

  <!-- #{2} -->
  <string-array name="intervalValues">
    <item>0</item>
    <item>900000</item>
    <item>1800000</item>
    <item>3600000</item>
    <item>43200000</item>
    <item>86400000</item>
  </string-array>
</resources>
{/CODE}

% + These will be the names of options that show up in the list.
% + These will be their corresponding values.

+ 不同的选项名。
+ 选项名对应的值。


% + Now that we have these arrays, we can update prefs.xml to add our list of intervals.

有了这两列数组，接下来修改prefs.xml添加Interval(时间间隔)选项。

**Example 13.13. prefs.xml with support for interval preference setting**

{CODE}
<?xml version="1.0" encoding="utf-8"?>
<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
  ...
  <!-- #{1} -->
  <ListPreference android:entryValues="@array/intervalValues"
    android:summary="@string/summaryUpdaterInterval"
    android:title="@string/titleUpdaterInterval"
    android:entries="@array/interval" android:key="interval" />
</PreferenceScreen>
{/CODE}

% + This is the list preference. It shows as a list of entities as represented by android:entities. The value associated with it comes from android:entityValues.

+ 这个选项条目是ListPreference。它显示一列单选选项，其中的文本由android:entries表示，对应的值由android:entryValues表示。

%TALK: 原文错误：entityValues该是entryValues，entities该是entries。

% Now we are ready to update the Boot receiver and add the Alarm service alarms.

接下来修改BootReceiver，添加Alarm服务相关的代码。

% ===Updating Boot Receiver===
===修改BootReceiver===

% If you recall from the section called “BootReceiver”, a Boot Receiver wakes up every time the device is booted up. So far, our Boot Receiver just starts our Updater service. That was fine when the Updater service was always on and running. But now, it would cause only a one-time execution of the Updater.

回忆下前面的"BootReceiver"一节。BootReceiver在设备开机时唤醒，先前我们利用这一特性，在这里启动UpdaterService，而UpdaterService将一直处于运行状态。但是到现在，UpdaterService会一次性退出，这样已经不再适用了。

% What we can do instead is use the Alarm service to periodically fire intents to start our Updater service. To do that, we’ll get the reference to the Alarm manager, create a Pending intent to be started each time, and set up the interval at which to start the updates. As our Pending intent is to start a service, we’ll use PendingIntent.getService() call, as described in the section called “Pending Intents”.

适用的是，使用Alarm服务定时发送Intent启动UpdaterService。为此，我们需要得到AlarmManager的引用，创建一个PendingIntent负责启动UpdaterService，并设置一个时间间隔。要PendingIntent启动Service，就调用PendingIntent.getService()。

**Example 13.14. BootReceiver.java updated with Alarm service calls to periodically start Updater service**
{CODE}
package com.marakana.yamba8;

import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

public class BootReceiver extends BroadcastReceiver {

  @Override
  public void onReceive(Context context, Intent callingIntent) {

    // Check if we should do anything at boot at all
    long interval = ((YambaApplication) context.getApplicationContext())
        .getInterval(); // #{1}
    if (interval == YambaApplication.INTERVAL_NEVER)  // #{2}
      return;

    // Create the pending intent
    Intent intent = new Intent(context, UpdaterService.class);  // #{3}
    PendingIntent pendingIntent = PendingIntent.getService(context, -1, intent,
        PendingIntent.FLAG_UPDATE_CURRENT); // #{4}

    // Setup alarm service to wake up and start service periodically
    AlarmManager alarmManager = (AlarmManager) context
        .getSystemService(Context.ALARM_SERVICE); // #{5}
    alarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME, System
        .currentTimeMillis(), interval, pendingIntent); // #{6}

    Log.d("BootReceiver", "onReceived");
  }

}
{/CODE}

% + Our Yamba application has a simple getter method to return the value of the interval preference.
% + We check user’s preference to set how often to check for network updates. A value of INTERVAL_NEVER (zero) means not to check for updates at all.
% + This is the intent that will run to start our Updater service.
% + Here we wrap that intent with the action to start a service and get a new Pending intent. The value of -1 is for a request code that is currently not being used. The flag in the final argument indicates that whether this intent already exists. We need just to update it and not recreate it.
% + We get the reference to AlarmManager via the usual getSystemService() call.
% + setInexactRepeating() specifies that we’d like this pending intent to be sent repeatedly, but we’re not concerned with being exactly on time. The ELAPSED_REALTIME flag will keep the alarm from waking up the phone just to run the updates. The other parameters are the current time as the start time for this alarm, our desired interval, and the actual Pending intent to execute when the alarm runs.


+ ``YambaApplication``对象中有个简单的getter方法，可以返回interval选项的值。
+ 检查用户设置，如果interval的值为``INTERVAL_NEVER``(零)，那就不检查更新。
+ 这个Intent负责启动UpdaterService。
+ 将Intent与启动Service的操作绑定起来，创建新的PendingIntent。``-1``表示没有使用requestCode。最后一个参数表示这个Intent是否已存在，我们不需要重新创建Intent，因此仅仅更新(update)当前已有的Intent。
+ 通过``getSystemService()``获取AlarmManager的引用。
+ ``setInexactRepeating()``表示这个PendingIntent将被重复发送，但并不关心时间精确与否。ELAPSED_REALTIME表示Alarm仅在设备活动时有效，而在待机时暂停。后面的参数分别指Alarm的开始时间、interval、以及将要执行的PendingIntent。


% You can now install our application on a device (and thus install the updated Boot Receiver), then reboot the device. Once the device starts, the logcat should indicate that the Boot receiver ran and started the Updater service by posting a Pending intent to the Alarm service.

接下来可以将我们的程序安装在设备上(这就安装了更新BootReceiver)，并重启设备。在设备开机时，logcat即可观察到BootReceiver启动，并通过Alarm服务启动了UpdaterService。


% ==Sending Notifications==
==发送通知==

% Here’s an opportunity to introduce yet another system service—this time the Notification service. We worked hard to have our Updater service run in the background and get the latest status updates, but what’s the point of all this work if the user is not made aware that there’s something new to look at? A standard Android UI approach to this would be to post a notification to the notification bar up at the top of the screen. To do that, we use Notification system service.

到这里再体验一个系统服务——那就是Notification服务。前面我们花了大功夫让UpdaterService在后台运行，并定期抓取消息的最新更新。但是如果用户压根注意不到它，那么这些工作还有什么意义？Android的标准解决方案就是，在屏幕顶部的通知栏弹出一个通知。而实现这一功能，需要用到Notification服务。

% We’re going to make the Updater service responsible for posting the notifications, since it is the part of the app that knows of new statuses in the first place. To do that, we’ll get the reference to the system Notification service, create a new Notification object, and update it with the latest information. The notification itself will contain a Pending Intent so that when the user clicks on it, it takes the user to Timeline Activity to view the latest status updates.

收到新消息，由UpdaterService首先得知，因此我们把通知的功能加入到UpdaterService里面：先获取Notification服务的引用，创建一个Notification对象，然后将收到消息的相关信息作为通知交给它。而Notification对象本身带有一个PendingIntent，当用户点击通知的时候，可以将界面转到TimelineActivity。

**Example 13.15. UpdaterService.java with Notifications**

{CODE}
package com.marakana.yamba8;

import android.app.IntentService;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Intent;
import android.util.Log;

public class UpdaterService extends IntentService {
  private static final String TAG = "UpdaterService";

  public static final String NEW_STATUS_INTENT = "com.marakana.yamba.NEW_STATUS";
  public static final String NEW_STATUS_EXTRA_COUNT = "NEW_STATUS_EXTRA_COUNT";
  public static final String RECEIVE_TIMELINE_NOTIFICATIONS = "com.marakana.yamba.RECEIVE_TIMELINE_NOTIFICATIONS";

  private NotificationManager notificationManager; // #{1}
  private Notification notification; // #{2}

  public UpdaterService() {
    super(TAG);

    Log.d(TAG, "UpdaterService constructed");
  }

  @Override
  protected void onHandleIntent(Intent inIntent) {
    Intent intent;
    this.notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); // #{3}
    this.notification = new Notification(android.R.drawable.stat_notify_chat,
        "", 0); // #{4}

    Log.d(TAG, "onHandleIntent'ing");
    YambaApplication yamba = (YambaApplication) getApplication();
    int newUpdates = yamba.fetchStatusUpdates();
    if (newUpdates > 0) {
      Log.d(TAG, "We have a new status");
      intent = new Intent(NEW_STATUS_INTENT);
      intent.putExtra(NEW_STATUS_EXTRA_COUNT, newUpdates);
      sendBroadcast(intent, RECEIVE_TIMELINE_NOTIFICATIONS);
      sendTimelineNotification(newUpdates); // #{5}
    }
  }

  /**
   * Creates a notification in the notification bar telling user there are new
   * messages
   *
   * @param timelineUpdateCount
   *          Number of new statuses
   */
  private void sendTimelineNotification(int timelineUpdateCount) {
    Log.d(TAG, "sendTimelineNotification'ing");
    PendingIntent pendingIntent = PendingIntent.getActivity(this, -1,
        new Intent(this, TimelineActivity.class),
        PendingIntent.FLAG_UPDATE_CURRENT); // #{6}
    this.notification.when = System.currentTimeMillis(); // #{7}
    this.notification.flags |= Notification.FLAG_AUTO_CANCEL; // #{8}
    CharSequence notificationTitle = this
        .getText(R.string.msgNotificationTitle); // #{9}
    CharSequence notificationSummary = this.getString(
        R.string.msgNotificationMessage, timelineUpdateCount);
    this.notification.setLatestEventInfo(this, notificationTitle,
        notificationSummary, pendingIntent); // #{10}
    this.notificationManager.notify(0, this.notification);
    Log.d(TAG, "sendTimelineNotificationed");
  }

}
{/CODE}

% + This is just our local reference to the NotificationManager class, which is our access to the Notification system service.
% + We create a class-global Notification object and update it each time there’s something new to notify our listeners about.
% + We obtain the reference to the Notification service via the usual getSystemService() call.
% + We create the notification object that we’ll reuse later. For now, we just specify the standard icon to use with our notification, and leave the text and timestamp to be updated later when we are about to post this notification.
% + We call our private sendTimelineNotification() method once we know there are new statuses to notify the user of.
% + This Pending intent will be kicked off when user checks the notification in the notification bar and clicks on the actual notification item. In this case, we want to take the user to the Timeline activity, so we create an intent for that.
% + We’re now updating the data for the most recent notification. This is the timestamp when it happened.
% + This flag tells the Notification manager to cancel this notification as soon as the user clicks on it. The notification will be removed from the notification bar at that point.
% + Here, we get the title and summary to go into the notification from our strings.xml file. Notice that the summary has parameters, so that we can use String.format() to update the actual number of new statuses.

% + Finally, we tell the Notification manager to post this notification. In this case, we do not need the ID, so we specify zero. An ID can be used to refer to a notification later, usually in order to cancel it.

+ 指向NotificationManager的私有类成员，也就通过它来访问Notification系统服务。
+ 创建一个Notification对象供类成员访问，每得到新消息需要发送通知时就更新它。
+ 调用``getSystemService()``获取Notification服务。
+ 创建Notification对象，在稍后使用。在这里先给它指明一个图标，至于通知的文本和timestamp则暂时留空。
+ 私有方法``sendTimelineNotification()``，在得到新消息时调用它发送通知。
+ 当用户收到通知并点击通知条目时，切换到Timeline界面，这个PendingIntent也随之销毁。 
+ 更新Notification对象的相关信息。这里是最新消息的timestamp。
+ 要求NotificationManager在用户点击时关闭这项通知，届时通知栏将不再显示这项通知。
+ 为Notification对象提供标题(title)与简介(summary)，都是取自``string.xml``中的字符串。留意``R.string.msgNotificationMessage``里面留了一个参数，表示新消息的数目，因此我们可以使用``String.format()``。
+ 最后，要求NotificationManager发送这条通知。在这里，我们不需要通知的ID，因此留0。ID是引用Notification对象的标识符，通常用来关闭一个通知。


% ==Summary==
==总结==

% At this point you have seen a few system services: Sensor, Location, Alarm, and Notification. There are a few more services provided by Android. You may have noticed that most of them have a lot of similarities, an hopefully you have started extrapolating certain patterns. We have also used this chapter to somewhat simplify our Updater service and introduce IntentServices and PendingIntents.

到这里，我们已经观察了几个系统服务：Sensor服务、Location服务、Alarm服务以及Notification服务。除此之外，Android还提供了很多其它的系统服务，篇幅所限未能提及。但你可以留意到它们之间的共性，有一些自己的总结。另外，我们在重构UpdaterService时，也用到了``IntentService``与``PendingIntent``。




